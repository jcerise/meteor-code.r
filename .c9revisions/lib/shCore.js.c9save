{"ts":1351661054146,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1351661165824,"patch":[[{"diffs":[[1,"/**\r\n * SyntaxHighlighter\r\n * http://alexgorbatchev.com/SyntaxHighlighter\r\n *\r\n * SyntaxHighlighter is donationware. If you are using it, please donate.\r\n * http://alexgorbatchev.com/SyntaxHighlighter/donate.html\r\n *\r\n * @version\r\n * 3.0.83 (July 02 2010)\r\n * \r\n * @copyright\r\n * Copyright (C) 2004-2010 Alex Gorbatchev.\r\n *\r\n * @license\r\n * Dual licensed under the MIT and GPL licenses.\r\n */\r\n//\r\n// Begin anonymous function. This is used to contain local scope variables without polutting global scope.\r\n//\r\nvar SyntaxHighlighter = function() { \r\n\r\n// CommonJS\r\nif (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')\r\n{\r\n    XRegExp = require('XRegExp').XRegExp;\r\n}\r\n\r\n// Shortcut object which will be assigned to the SyntaxHighlighter variable.\r\n// This is a shorthand for local reference in order to avoid long namespace \r\n// references to SyntaxHighlighter.whatever...\r\nvar sh = {\r\n\tdefaults : {\r\n\t\t/** Additional CSS class names to be added to highlighter elements. */\r\n\t\t'class-name' : '',\r\n\t\t\r\n\t\t/** First line number. */\r\n\t\t'first-line' : 1,\r\n\t\t\r\n\t\t/**\r\n\t\t * Pads line numbers. Possible values are:\r\n\t\t *\r\n\t\t *   false - don't pad line numbers.\r\n\t\t *   true  - automaticaly pad numbers with minimum required number of leading zeroes.\r\n\t\t *   [int] - length up to which pad line numbers.\r\n\t\t */\r\n\t\t'pad-line-numbers' : false,\r\n\t\t\r\n\t\t/** Lines to highlight. */\r\n\t\t'highlight' : null,\r\n\t\t\r\n\t\t/** Title to be displayed above the code block. */\r\n\t\t'title' : null,\r\n\t\t\r\n\t\t/** Enables or disables smart tabs. */\r\n\t\t'smart-tabs' : true,\r\n\t\t\r\n\t\t/** Gets or sets tab size. */\r\n\t\t'tab-size' : 4,\r\n\t\t\r\n\t\t/** Enables or disables gutter. */\r\n\t\t'gutter' : true,\r\n\t\t\r\n\t\t/** Enables or disables toolbar. */\r\n\t\t'toolbar' : true,\r\n\t\t\r\n\t\t/** Enables quick code copy and paste from double click. */\r\n\t\t'quick-code' : true,\r\n\t\t\r\n\t\t/** Forces code view to be collapsed. */\r\n\t\t'collapse' : false,\r\n\t\t\r\n\t\t/** Enables or disables automatic links. */\r\n\t\t'auto-links' : true,\r\n\t\t\r\n\t\t/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */\r\n\t\t'light' : false,\r\n\t\t\r\n\t\t'html-script' : false\r\n\t},\r\n\t\r\n\tconfig : {\r\n\t\tspace : '&nbsp;',\r\n\t\t\r\n\t\t/** Enables use of <SCRIPT type=\"syntaxhighlighter\" /> tags. */\r\n\t\tuseScriptTags : true,\r\n\t\t\r\n\t\t/** Blogger mode flag. */\r\n\t\tbloggerMode : false,\r\n\t\t\r\n\t\tstripBrs : false,\r\n\t\t\r\n\t\t/** Name of the tag that SyntaxHighlighter will automatically look for. */\r\n\t\ttagName : 'pre',\r\n\t\t\r\n\t\tstrings : {\r\n\t\t\texpandSource : 'expand source',\r\n\t\t\thelp : '?',\r\n\t\t\talert: 'SyntaxHighlighter\\n\\n',\r\n\t\t\tnoBrush : 'Can\\'t find brush for: ',\r\n\t\t\tbrushNotHtmlScript : 'Brush wasn\\'t configured for html-script option: ',\r\n\t\t\t\r\n\t\t\t// this is populated by the build script\r\n\t\t\taboutDialog : '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /><title>About SyntaxHighlighter</title></head><body style=\"font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;\"><div style=\"text-align:center;margin-top:1.5em;\"><div style=\"font-size:xx-large;\">SyntaxHighlighter</div><div style=\"font-size:.75em;margin-bottom:3em;\"><div>version 3.0.83 (July 02 2010)</div><div><a href=\"http://alexgorbatchev.com/SyntaxHighlighter\" target=\"_blank\" style=\"color:#005896\">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402\" style=\"color:#005896\">donate</a> to <br/>keep development active!</div></div></body></html>'\r\n\t\t}\r\n\t},\r\n\t\r\n\t/** Internal 'global' variables. */\r\n\tvars : {\r\n\t\tdiscoveredBrushes : null,\r\n\t\thighlighters : {}\r\n\t},\r\n\t\r\n\t/** This object is populated by user included external brush files. */\r\n\tbrushes : {},\r\n\r\n\t/** Common regular expressions. */\r\n\tregexLib : {\r\n\t\tmultiLineCComments\t\t\t: /\\/\\*[\\s\\S]*?\\*\\//gm,\r\n\t\tsingleLineCComments\t\t\t: /\\/\\/.*$/gm,\r\n\t\tsingleLinePerlComments\t\t: /#.*$/gm,\r\n\t\tdoubleQuotedString\t\t\t: /\"([^\\\\\"\\n]|\\\\.)*\"/g,\r\n\t\tsingleQuotedString\t\t\t: /'([^\\\\'\\n]|\\\\.)*'/g,\r\n\t\tmultiLineDoubleQuotedString\t: new XRegExp('\"([^\\\\\\\\\"]|\\\\\\\\.)*\"', 'gs'),\r\n\t\tmultiLineSingleQuotedString\t: new XRegExp(\"'([^\\\\\\\\']|\\\\\\\\.)*'\", 'gs'),\r\n\t\txmlComments\t\t\t\t\t: /(&lt;|<)!--[\\s\\S]*?--(&gt;|>)/gm,\r\n\t\turl\t\t\t\t\t\t\t: /\\w+:\\/\\/[\\w-.\\/?%&=:@;]*/g,\r\n\t\t\r\n\t\t/** <?= ?> tags. */\r\n\t\tphpScriptTags \t\t\t\t: { left: /(&lt;|<)\\?=?/g, right: /\\?(&gt;|>)/g },\r\n\t\t\r\n\t\t/** <%= %> tags. */\r\n\t\taspScriptTags\t\t\t\t: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },\r\n\t\t\r\n\t\t/** <script></script> tags. */\r\n\t\tscriptScriptTags\t\t\t: { left: /(&lt;|<)\\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\\/\\s*script\\s*(&gt;|>)/gi }\r\n\t},\r\n\r\n\ttoolbar: {\r\n\t\t/**\r\n\t\t * Generates HTML markup for the toolbar.\r\n\t\t * @param {Highlighter} highlighter Highlighter instance.\r\n\t\t * @return {String} Returns HTML markup.\r\n\t\t */\r\n\t\tgetHtml: function(highlighter)\r\n\t\t{\r\n\t\t\tvar html = '<div class=\"toolbar\">',\r\n\t\t\t\titems = sh.toolbar.items,\r\n\t\t\t\tlist = items.list\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tfunction defaultGetHtml(highlighter, name)\r\n\t\t\t{\r\n\t\t\t\treturn sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tfor (var i = 0; i < list.length; i++)\r\n\t\t\t\thtml += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);\r\n\t\t\t\r\n\t\t\thtml += '</div>';\r\n\t\t\t\r\n\t\t\treturn html;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Generates HTML markup for a regular button in the toolbar.\r\n\t\t * @param {Highlighter} highlighter Highlighter instance.\r\n\t\t * @param {String} commandName\t\tCommand name that would be executed.\r\n\t\t * @param {String} label\t\t\tLabel text to display.\r\n\t\t * @return {String}\t\t\t\t\tReturns HTML markup.\r\n\t\t */\r\n\t\tgetButtonHtml: function(highlighter, commandName, label)\r\n\t\t{\r\n\t\t\treturn '<span><a href=\"#\" class=\"toolbar_item'\r\n\t\t\t\t+ ' command_' + commandName\r\n\t\t\t\t+ ' ' + commandName\r\n\t\t\t\t+ '\">' + label + '</a></span>'\r\n\t\t\t\t;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Event handler for a toolbar anchor.\r\n\t\t */\r\n\t\thandler: function(e)\r\n\t\t{\r\n\t\t\tvar target = e.target,\r\n\t\t\t\tclassName = target.className || ''\r\n\t\t\t\t;\r\n\r\n\t\t\tfunction getValue(name)\r\n\t\t\t{\r\n\t\t\t\tvar r = new RegExp(name + '_(\\\\w+)'),\r\n\t\t\t\t\tmatch = r.exec(className)\r\n\t\t\t\t\t;\r\n\r\n\t\t\t\treturn match ? match[1] : null;\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),\r\n\t\t\t\tcommandName = getValue('command')\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\t// execute the toolbar command\r\n\t\t\tif (highlighter && commandName)\r\n\t\t\t\tsh.toolbar.items[commandName].execute(highlighter);\r\n\r\n\t\t\t// disable default A click behaviour\r\n\t\t\te.preventDefault();\r\n\t\t},\r\n\t\t\r\n\t\t/** Collection of toolbar items. */\r\n\t\titems : {\r\n\t\t\t// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.\r\n\t\t\tlist: ['expandSource', 'help'],\r\n\r\n\t\t\texpandSource: {\r\n\t\t\t\tgetHtml: function(highlighter)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (highlighter.getParam('collapse') != true)\r\n\t\t\t\t\t\treturn '';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tvar title = highlighter.getParam('title');\r\n\t\t\t\t\treturn sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);\r\n\t\t\t\t},\r\n\t\t\t\r\n\t\t\t\texecute: function(highlighter)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar div = getHighlighterDivById(highlighter.id);\r\n\t\t\t\t\tremoveClass(div, 'collapsed');\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t/** Command to display the about dialog window. */\r\n\t\t\thelp: {\r\n\t\t\t\texecute: function(highlighter)\r\n\t\t\t\t{\t\r\n\t\t\t\t\tvar wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),\r\n\t\t\t\t\t\tdoc = wnd.document\r\n\t\t\t\t\t\t;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdoc.write(sh.config.strings.aboutDialog);\r\n\t\t\t\t\tdoc.close();\r\n\t\t\t\t\twnd.focus();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Finds all elements on the page which should be processes by SyntaxHighlighter.\r\n\t *\r\n\t * @param {Object} globalParams\t\tOptional parameters which override element's \r\n\t * \t\t\t\t\t\t\t\t\tparameters. Only used if element is specified.\r\n\t * \r\n\t * @param {Object} element\tOptional element to highlight. If none is\r\n\t * \t\t\t\t\t\t\tprovided, all elements in the current document \r\n\t * \t\t\t\t\t\t\tare returned which qualify.\r\n\t *\r\n\t * @return {Array}\tReturns list of <code>{ target: DOMElement, params: Object }</code> objects.\r\n\t */\r\n\tfindElements: function(globalParams, element)\r\n\t{\r\n\t\tvar elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), \r\n\t\t\tconf = sh.config,\r\n\t\t\tresult = []\r\n\t\t\t;\r\n\r\n\t\t// support for <SCRIPT TYPE=\"syntaxhighlighter\" /> feature\r\n\t\tif (conf.useScriptTags)\r\n\t\t\telements = elements.concat(getSyntaxHighlighterScriptTags());\r\n\r\n\t\tif (elements.length === 0) \r\n\t\t\treturn result;\r\n\t\r\n\t\tfor (var i = 0; i < elements.length; i++) \r\n\t\t{\r\n\t\t\tvar item = {\r\n\t\t\t\ttarget: elements[i], \r\n\t\t\t\t// local params take precedence over globals\r\n\t\t\t\tparams: merge(globalParams, parseParams(elements[i].className))\r\n\t\t\t};\r\n\r\n\t\t\tif (item.params['brush'] == null)\r\n\t\t\t\tcontinue;\r\n\t\t\t\t\r\n\t\t\tresult.push(item);\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Shorthand to highlight all elements on the page that are marked as \r\n\t * SyntaxHighlighter source code.\r\n\t * \r\n\t * @param {Object} globalParams\t\tOptional parameters which override element's \r\n\t * \t\t\t\t\t\t\t\t\tparameters. Only used if element is specified.\r\n\t * \r\n\t * @param {Object} element\tOptional element to highlight. If none is\r\n\t * \t\t\t\t\t\t\tprovided, all elements in the current document \r\n\t * \t\t\t\t\t\t\tare highlighted.\r\n\t */ \r\n\thighlight: function(globalParams, element)\r\n\t{\r\n\t\tvar elements = this.findElements(globalParams, element),\r\n\t\t\tpropertyName = 'innerHTML', \r\n\t\t\thighlighter = null,\r\n\t\t\tconf = sh.config\r\n\t\t\t;\r\n\r\n\t\tif (elements.length === 0) \r\n\t\t\treturn;\r\n\t\r\n\t\tfor (var i = 0; i < elements.length; i++) \r\n\t\t{\r\n\t\t\tvar element = elements[i],\r\n\t\t\t\ttarget = element.target,\r\n\t\t\t\tparams = element.params,\r\n\t\t\t\tbrushName = params.brush,\r\n\t\t\t\tcode\r\n\t\t\t\t;\r\n\r\n\t\t\tif (brushName == null)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t// Instantiate a brush\r\n\t\t\tif (params['html-script'] == 'true' || sh.defaults['html-script'] == true) \r\n\t\t\t{\r\n\t\t\t\thighlighter = new sh.HtmlScript(brushName);\r\n\t\t\t\tbrushName = 'htmlscript';\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar brush = findBrush(brushName);\r\n\t\t\t\t\r\n\t\t\t\tif (brush)\r\n\t\t\t\t\thighlighter = new brush();\r\n\t\t\t\telse\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcode = target[propertyName];\r\n\t\t\t\r\n\t\t\t// remove CDATA from <SCRIPT/> tags if it's present\r\n\t\t\tif (conf.useScriptTags)\r\n\t\t\t\tcode = stripCData(code);\r\n\t\t\t\t\r\n\t\t\t// Inject title if the attribute is present\r\n\t\t\tif ((target.title || '') != '')\r\n\t\t\t\tparams.title = target.title;\r\n\t\t\t\t\r\n\t\t\tparams['brush'] = brushName;\r\n\t\t\thighlighter.init(params);\r\n\t\t\telement = highlighter.getDiv(code);\r\n\t\t\t\r\n\t\t\t// carry over ID\r\n\t\t\tif ((target.id || '') != '')\r\n\t\t\t\telement.id = target.id;\r\n\t\t\t\r\n\t\t\ttarget.parentNode.replaceChild(element, target);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Main entry point for the SyntaxHighlighter.\r\n\t * @param {Object} params Optional params to apply to all highlighted elements.\r\n\t */\r\n\tall: function(params)\r\n\t{\r\n\t\tattachEvent(\r\n\t\t\twindow,\r\n\t\t\t'load',\r\n\t\t\tfunction() { sh.highlight(params); }\r\n\t\t);\r\n\t}\r\n}; // end of sh\r\n\r\nsh['all']\t\t\t= sh.all;\r\nsh['highlight']\t\t= sh.highlight;\r\n\r\n/**\r\n * Checks if target DOM elements has specified CSS class.\r\n * @param {DOMElement} target Target DOM element to check.\r\n * @param {String} className Name of the CSS class to check for.\r\n * @return {Boolean} Returns true if class name is present, false otherwise.\r\n */\r\nfunction hasClass(target, className)\r\n{\r\n\treturn target.className.indexOf(className) != -1;\r\n};\r\n\r\n/**\r\n * Adds CSS class name to the target DOM element.\r\n * @param {DOMElement} target Target DOM element.\r\n * @param {String} className New CSS class to add.\r\n */\r\nfunction addClass(target, className)\r\n{\r\n\tif (!hasClass(target, className))\r\n\t\ttarget.className += ' ' + className;\r\n};\r\n\r\n/**\r\n * Removes CSS class name from the target DOM element.\r\n * @param {DOMElement} target Target DOM element.\r\n * @param {String} className CSS class to remove.\r\n */\r\nfunction removeClass(target, className)\r\n{\r\n\ttarget.className = target.className.replace(className, '');\r\n};\r\n\r\n/**\r\n * Converts the source to array object. Mostly used for function arguments and \r\n * lists returned by getElementsByTagName() which aren't Array objects.\r\n * @param {List} source Source list.\r\n * @return {Array} Returns array.\r\n */\r\nfunction toArray(source)\r\n{\r\n\tvar result = [];\r\n\t\r\n\tfor (var i = 0; i < source.length; i++) \r\n\t\tresult.push(source[i]);\r\n\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Splits block of text into lines.\r\n * @param {String} block Block of text.\r\n * @return {Array} Returns array of lines.\r\n */\r\nfunction splitLines(block)\r\n{\r\n\treturn block.split('\\n');\r\n}\r\n\r\n/**\r\n * Generates HTML ID for the highlighter.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {String} Returns HTML ID.\r\n */\r\nfunction getHighlighterId(id)\r\n{\r\n\tvar prefix = 'highlighter_';\r\n\treturn id.indexOf(prefix) == 0 ? id : prefix + id;\r\n};\r\n\r\n/**\r\n * Finds Highlighter instance by ID.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {Highlighter} Returns instance of the highlighter.\r\n */\r\nfunction getHighlighterById(id)\r\n{\r\n\treturn sh.vars.highlighters[getHighlighterId(id)];\r\n};\r\n\r\n/**\r\n * Finds highlighter's DIV container.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {Element} Returns highlighter's DIV element.\r\n */\r\nfunction getHighlighterDivById(id)\r\n{\r\n\treturn document.getElementById(getHighlighterId(id));\r\n};\r\n\r\n/**\r\n * Stores highlighter so that getHighlighterById() can do its thing. Each\r\n * highlighter must call this method to preserve itself.\r\n * @param {Highilghter} highlighter Highlighter instance.\r\n */\r\nfunction storeHighlighter(highlighter)\r\n{\r\n\tsh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;\r\n};\r\n\r\n/**\r\n * Looks for a child or parent node which has specified classname.\r\n * Equivalent to jQuery's $(container).find(\".className\")\r\n * @param {Element} target Target element.\r\n * @param {String} search Class name or node name to look for.\r\n * @param {Boolean} reverse If set to true, will go up the node tree instead of down.\r\n * @return {Element} Returns found child or parent element on null.\r\n */\r\nfunction findElement(target, search, reverse /* optional */)\r\n{\r\n\tif (target == null)\r\n\t\treturn null;\r\n\t\t\r\n\tvar nodes\t\t\t= reverse != true ? target.childNodes : [ target.parentNode ],\r\n\t\tpropertyToFind\t= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',\r\n\t\texpectedValue,\r\n\t\tfound\r\n\t\t;\r\n\r\n\texpectedValue = propertyToFind != 'nodeName'\r\n\t\t? search.substr(1)\r\n\t\t: search.toUpperCase()\r\n\t\t;\r\n\t\t\r\n\t// main return of the found node\r\n\tif ((target[propertyToFind] || '').indexOf(expectedValue) != -1)\r\n\t\treturn target;\r\n\t\r\n\tfor (var i = 0; nodes && i < nodes.length && found == null; i++)\r\n\t\tfound = findElement(nodes[i], search, reverse);\r\n\t\r\n\treturn found;\r\n};\r\n\r\n/**\r\n * Looks for a parent node which has specified classname.\r\n * This is an alias to <code>findElement(container, className, true)</code>.\r\n * @param {Element} target Target element.\r\n * @param {String} className Class name to look for.\r\n * @return {Element} Returns found parent element on null.\r\n */\r\nfunction findParentElement(target, className)\r\n{\r\n\treturn findElement(target, className, true);\r\n};\r\n\r\n/**\r\n * Finds an index of element in the array.\r\n * @ignore\r\n * @param {Object} searchElement\r\n * @param {Number} fromIndex\r\n * @return {Number} Returns index of element if found; -1 otherwise.\r\n */\r\nfunction indexOf(array, searchElement, fromIndex)\r\n{\r\n\tfromIndex = Math.max(fromIndex || 0, 0);\r\n\r\n\tfor (var i = fromIndex; i < array.length; i++)\r\n\t\tif(array[i] == searchElement)\r\n\t\t\treturn i;\r\n\t\r\n\treturn -1;\r\n};\r\n\r\n/**\r\n * Generates a unique element ID.\r\n */\r\nfunction guid(prefix)\r\n{\r\n\treturn (prefix || '') + Math.round(Math.random() * 1000000).toString();\r\n};\r\n\r\n/**\r\n * Merges two objects. Values from obj2 override values in obj1.\r\n * Function is NOT recursive and works only for one dimensional objects.\r\n * @param {Object} obj1 First object.\r\n * @param {Object} obj2 Second object.\r\n * @return {Object} Returns combination of both objects.\r\n */\r\nfunction merge(obj1, obj2)\r\n{\r\n\tvar result = {}, name;\r\n\r\n\tfor (name in obj1) \r\n\t\tresult[name] = obj1[name];\r\n\t\r\n\tfor (name in obj2) \r\n\t\tresult[name] = obj2[name];\r\n\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Attempts to convert string to boolean.\r\n * @param {String} value Input string.\r\n * @return {Boolean} Returns true if input was \"true\", false if input was \"false\" and value otherwise.\r\n */\r\nfunction toBoolean(value)\r\n{\r\n\tvar result = { \"true\" : true, \"false\" : false }[value];\r\n\treturn result == null ? value : result;\r\n};\r\n\r\n/**\r\n * Opens up a centered popup window.\r\n * @param {String} url\t\tURL to open in the window.\r\n * @param {String} name\t\tPopup name.\r\n * @param {int} width\t\tPopup width.\r\n * @param {int} height\t\tPopup height.\r\n * @param {String} options\twindow.open() options.\r\n * @return {Window}\t\t\tReturns window instance.\r\n */\r\nfunction popup(url, name, width, height, options)\r\n{\r\n\tvar x = (screen.width - width) / 2,\r\n\t\ty = (screen.height - height) / 2\r\n\t\t;\r\n\t\t\r\n\toptions +=\t', left=' + x + \r\n\t\t\t\t', top=' + y +\r\n\t\t\t\t', width=' + width +\r\n\t\t\t\t', height=' + height\r\n\t\t;\r\n\toptions = options.replace(/^,/, '');\r\n\r\n\tvar win = window.open(url, name, options);\r\n\twin.focus();\r\n\treturn win;\r\n};\r\n\r\n/**\r\n * Adds event handler to the target object.\r\n * @param {Object} obj\t\tTarget object.\r\n * @param {String} type\t\tName of the event.\r\n * @param {Function} func\tHandling function.\r\n */\r\nfunction attachEvent(obj, type, func, scope)\r\n{\r\n\tfunction handler(e)\r\n\t{\r\n\t\te = e || window.event;\r\n\t\t\r\n\t\tif (!e.target)\r\n\t\t{\r\n\t\t\te.target = e.srcElement;\r\n\t\t\te.preventDefault = function()\r\n\t\t\t{\r\n\t\t\t\tthis.returnValue = false;\r\n\t\t\t};\r\n\t\t}\r\n\t\t\t\r\n\t\tfunc.call(scope || window, e);\r\n\t};\r\n\t\r\n\tif (obj.attachEvent) \r\n\t{\r\n\t\tobj.attachEvent('on' + type, handler);\r\n\t}\r\n\telse \r\n\t{\r\n\t\tobj.addEventListener(type, handler, false);\r\n\t}\r\n};\r\n\r\n/**\r\n * Displays an alert.\r\n * @param {String} str String to display.\r\n */\r\nfunction alert(str)\r\n{\r\n\twindow.alert(sh.config.strings.alert + str);\r\n};\r\n\r\n/**\r\n * Finds a brush by its alias.\r\n *\r\n * @param {String} alias\t\tBrush alias.\r\n * @param {Boolean} showAlert\tSuppresses the alert if false.\r\n * @return {Brush}\t\t\t\tReturns bursh constructor if found, null otherwise.\r\n */\r\nfunction findBrush(alias, showAlert)\r\n{\r\n\tvar brushes = sh.vars.discoveredBrushes,\r\n\t\tresult = null\r\n\t\t;\r\n\t\r\n\tif (brushes == null) \r\n\t{\r\n\t\tbrushes = {};\r\n\t\t\r\n\t\t// Find all brushes\r\n\t\tfor (var brush in sh.brushes) \r\n\t\t{\r\n\t\t\tvar info = sh.brushes[brush],\r\n\t\t\t\taliases = info.aliases\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tif (aliases == null) \r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\t// keep the brush name\r\n\t\t\tinfo.brushName = brush.toLowerCase();\r\n\t\t\t\r\n\t\t\tfor (var i = 0; i < aliases.length; i++) \r\n\t\t\t\tbrushes[aliases[i]] = brush;\r\n\t\t}\r\n\t\t\r\n\t\tsh.vars.discoveredBrushes = brushes;\r\n\t}\r\n\t\r\n\tresult = sh.brushes[brushes[alias]];\r\n\r\n\tif (result == null && showAlert != false)\r\n\t\talert(sh.config.strings.noBrush + alias);\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Executes a callback on each line and replaces each line with result from the callback.\r\n * @param {Object} str\t\t\tInput string.\r\n * @param {Object} callback\t\tCallback function taking one string argument and returning a string.\r\n */\r\nfunction eachLine(str, callback)\r\n{\r\n\tvar lines = splitLines(str);\r\n\t\r\n\tfor (var i = 0; i < lines.length; i++)\r\n\t\tlines[i] = callback(lines[i], i);\r\n\t\t\r\n\treturn lines.join('\\n');\r\n};\r\n\r\n/**\r\n * This is a special trim which only removes first and last empty lines\r\n * and doesn't affect valid leading space on the first line.\r\n * \r\n * @param {String} str   Input string\r\n * @return {String}      Returns string without empty first and last lines.\r\n */\r\nfunction trimFirstAndLastLines(str)\r\n{\r\n\treturn str.replace(/^[ ]*[\\n]+|[\\n]*[ ]*$/g, '');\r\n};\r\n\r\n/**\r\n * Parses key/value pairs into hash object.\r\n * \r\n * Understands the following formats:\r\n * - name: word;\r\n * - name: [word, word];\r\n * - name: \"string\";\r\n * - name: 'string';\r\n * \r\n * For example:\r\n *   name1: value; name2: [value, value]; name3: 'value'\r\n *   \r\n * @param {String} str    Input string.\r\n * @return {Object}       Returns deserialized object.\r\n */\r\nfunction parseParams(str)\r\n{\r\n\tvar match, \r\n\t\tresult = {},\r\n\t\tarrayRegex = new XRegExp(\"^\\\\[(?<values>(.*?))\\\\]$\"),\r\n\t\tregex = new XRegExp(\r\n\t\t\t\"(?<name>[\\\\w-]+)\" +\r\n\t\t\t\"\\\\s*:\\\\s*\" +\r\n\t\t\t\"(?<value>\" +\r\n\t\t\t\t\"[\\\\w-%#]+|\" +\t\t// word\r\n\t\t\t\t\"\\\\[.*?\\\\]|\" +\t\t// [] array\r\n\t\t\t\t'\".*?\"|' +\t\t\t// \"\" string\r\n\t\t\t\t\"'.*?'\" +\t\t\t// '' string\r\n\t\t\t\")\\\\s*;?\",\r\n\t\t\t\"g\"\r\n\t\t)\r\n\t\t;\r\n\r\n\twhile ((match = regex.exec(str)) != null) \r\n\t{\r\n\t\tvar value = match.value\r\n\t\t\t.replace(/^['\"]|['\"]$/g, '') // strip quotes from end of strings\r\n\t\t\t;\r\n\t\t\r\n\t\t// try to parse array value\r\n\t\tif (value != null && arrayRegex.test(value))\r\n\t\t{\r\n\t\t\tvar m = arrayRegex.exec(value);\r\n\t\t\tvalue = m.values.length > 0 ? m.values.split(/\\s*,\\s*/) : [];\r\n\t\t}\r\n\t\t\r\n\t\tresult[match.name] = value;\r\n\t}\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Wraps each line of the string into <code/> tag with given style applied to it.\r\n * \r\n * @param {String} str   Input string.\r\n * @param {String} css   Style name to apply to the string.\r\n * @return {String}      Returns input string with each line surrounded by <span/> tag.\r\n */\r\nfunction wrapLinesWithCode(str, css)\r\n{\r\n\tif (str == null || str.length == 0 || str == '\\n') \r\n\t\treturn str;\r\n\r\n\tstr = str.replace(/</g, '&lt;');\r\n\r\n\t// Replace two or more sequential spaces with &nbsp; leaving last space untouched.\r\n\tstr = str.replace(/ {2,}/g, function(m)\r\n\t{\r\n\t\tvar spaces = '';\r\n\t\t\r\n\t\tfor (var i = 0; i < m.length - 1; i++)\r\n\t\t\tspaces += sh.config.space;\r\n\t\t\r\n\t\treturn spaces + ' ';\r\n\t});\r\n\r\n\t// Split each line and apply <span class=\"...\">...</span> to them so that\r\n\t// leading spaces aren't included.\r\n\tif (css != null) \r\n\t\tstr = eachLine(str, function(line)\r\n\t\t{\r\n\t\t\tif (line.length == 0) \r\n\t\t\t\treturn '';\r\n\t\t\t\r\n\t\t\tvar spaces = '';\r\n\t\t\t\r\n\t\t\tline = line.replace(/^(&nbsp;| )+/, function(s)\r\n\t\t\t{\r\n\t\t\t\tspaces = s;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (line.length == 0) \r\n\t\t\t\treturn spaces;\r\n\t\t\t\r\n\t\t\treturn spaces + '<code class=\"' + css + '\">' + line + '</code>';\r\n\t\t});\r\n\r\n\treturn str;\r\n};\r\n\r\n/**\r\n * Pads number with zeros until it's length is the same as given length.\r\n * \r\n * @param {Number} number\tNumber to pad.\r\n * @param {Number} length\tMax string length with.\r\n * @return {String}\t\t\tReturns a string padded with proper amount of '0'.\r\n */\r\nfunction padNumber(number, length)\r\n{\r\n\tvar result = number.toString();\r\n\t\r\n\twhile (result.length < length)\r\n\t\tresult = '0' + result;\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Replaces tabs with spaces.\r\n * \r\n * @param {String} code\t\tSource code.\r\n * @param {Number} tabSize\tSize of the tab.\r\n * @return {String}\t\t\tReturns code with all tabs replaces by spaces.\r\n */\r\nfunction processTabs(code, tabSize)\r\n{\r\n\tvar tab = '';\r\n\t\r\n\tfor (var i = 0; i < tabSize; i++)\r\n\t\ttab += ' ';\r\n\r\n\treturn code.replace(/\\t/g, tab);\r\n};\r\n\r\n/**\r\n * Replaces tabs with smart spaces.\r\n * \r\n * @param {String} code    Code to fix the tabs in.\r\n * @param {Number} tabSize Number of spaces in a column.\r\n * @return {String}        Returns code with all tabs replaces with roper amount of spaces.\r\n */\r\nfunction processSmartTabs(code, tabSize)\r\n{\r\n\tvar lines = splitLines(code),\r\n\t\ttab = '\\t',\r\n\t\tspaces = ''\r\n\t\t;\r\n\t\r\n\t// Create a string with 1000 spaces to copy spaces from... \r\n\t// It's assumed that there would be no indentation longer than that.\r\n\tfor (var i = 0; i < 50; i++) \r\n\t\tspaces += '                    '; // 20 spaces * 50\r\n\t\t\t\r\n\t// This function inserts specified amount of spaces in the string\r\n\t// where a tab is while removing that given tab.\r\n\tfunction insertSpaces(line, pos, count)\r\n\t{\r\n\t\treturn line.substr(0, pos)\r\n\t\t\t+ spaces.substr(0, count)\r\n\t\t\t+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab\r\n\t\t\t;\r\n\t};\r\n\r\n\t// Go through all the lines and do the 'smart tabs' magic.\r\n\tcode = eachLine(code, function(line)\r\n\t{\r\n\t\tif (line.indexOf(tab) == -1) \r\n\t\t\treturn line;\r\n\t\t\r\n\t\tvar pos = 0;\r\n\t\t\r\n\t\twhile ((pos = line.indexOf(tab)) != -1) \r\n\t\t{\r\n\t\t\t// This is pretty much all there is to the 'smart tabs' logic.\r\n\t\t\t// Based on the position within the line and size of a tab,\r\n\t\t\t// calculate the amount of spaces we need to insert.\r\n\t\t\tvar spaces = tabSize - pos % tabSize;\r\n\t\t\tline = insertSpaces(line, pos, spaces);\r\n\t\t}\r\n\t\t\r\n\t\treturn line;\r\n\t});\r\n\t\r\n\treturn code;\r\n};\r\n\r\n/**\r\n * Performs various string fixes based on configuration.\r\n */\r\nfunction fixInputString(str)\r\n{\r\n\tvar br = /<br\\s*\\/?>|&lt;br\\s*\\/?&gt;/gi;\r\n\t\r\n\tif (sh.config.bloggerMode == true)\r\n\t\tstr = str.replace(br, '\\n');\r\n\r\n\tif (sh.config.stripBrs == true)\r\n\t\tstr = str.replace(br, '');\r\n\t\t\r\n\treturn str;\r\n};\r\n\r\n/**\r\n * Removes all white space at the begining and end of a string.\r\n * \r\n * @param {String} str   String to trim.\r\n * @return {String}      Returns string without leading and following white space characters.\r\n */\r\nfunction trim(str)\r\n{\r\n\treturn str.replace(/^\\s+|\\s+$/g, '');\r\n};\r\n\r\n/**\r\n * Unindents a block of text by the lowest common indent amount.\r\n * @param {String} str   Text to unindent.\r\n * @return {String}      Returns unindented text block.\r\n */\r\nfunction unindent(str)\r\n{\r\n\tvar lines = splitLines(fixInputString(str)),\r\n\t\tindents = new Array(),\r\n\t\tregex = /^\\s*/,\r\n\t\tmin = 1000\r\n\t\t;\r\n\t\r\n\t// go through every line and check for common number of indents\r\n\tfor (var i = 0; i < lines.length && min > 0; i++) \r\n\t{\r\n\t\tvar line = lines[i];\r\n\t\t\r\n\t\tif (trim(line).length == 0) \r\n\t\t\tcontinue;\r\n\t\t\r\n\t\tvar matches = regex.exec(line);\r\n\t\t\r\n\t\t// In the event that just one line doesn't have leading white space\r\n\t\t// we can't unindent anything, so bail completely.\r\n\t\tif (matches == null) \r\n\t\t\treturn str;\r\n\t\t\t\r\n\t\tmin = Math.min(matches[0].length, min);\r\n\t}\r\n\t\r\n\t// trim minimum common number of white space from the begining of every line\r\n\tif (min > 0) \r\n\t\tfor (var i = 0; i < lines.length; i++) \r\n\t\t\tlines[i] = lines[i].substr(min);\r\n\t\r\n\treturn lines.join('\\n');\r\n};\r\n\r\n/**\r\n * Callback method for Array.sort() which sorts matches by\r\n * index position and then by length.\r\n * \r\n * @param {Match} m1\tLeft object.\r\n * @param {Match} m2    Right object.\r\n * @return {Number}     Returns -1, 0 or -1 as a comparison result.\r\n */\r\nfunction matchesSortCallback(m1, m2)\r\n{\r\n\t// sort matches by index first\r\n\tif(m1.index < m2.index)\r\n\t\treturn -1;\r\n\telse if(m1.index > m2.index)\r\n\t\treturn 1;\r\n\telse\r\n\t{\r\n\t\t// if index is the same, sort by length\r\n\t\tif(m1.length < m2.length)\r\n\t\t\treturn -1;\r\n\t\telse if(m1.length > m2.length)\r\n\t\t\treturn 1;\r\n\t}\r\n\t\r\n\treturn 0;\r\n};\r\n\r\n/**\r\n * Executes given regular expression on provided code and returns all\r\n * matches that are found.\r\n * \r\n * @param {String} code    Code to execute regular expression on.\r\n * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.\r\n * @return {Array}         Returns a list of Match objects.\r\n */ \r\nfunction getMatches(code, regexInfo)\r\n{\r\n\tfunction defaultAdd(match, regexInfo)\r\n\t{\r\n\t\treturn match[0];\r\n\t};\r\n\t\r\n\tvar index = 0,\r\n\t\tmatch = null,\r\n\t\tmatches = [],\r\n\t\tfunc = regexInfo.func ? regexInfo.func : defaultAdd\r\n\t\t;\r\n\t\r\n\twhile((match = regexInfo.regex.exec(code)) != null)\r\n\t{\r\n\t\tvar resultMatch = func(match, regexInfo);\r\n\t\t\r\n\t\tif (typeof(resultMatch) == 'string')\r\n\t\t\tresultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];\r\n\r\n\t\tmatches = matches.concat(resultMatch);\r\n\t}\r\n\t\r\n\treturn matches;\r\n};\r\n\r\n/**\r\n * Turns all URLs in the code into <a/> tags.\r\n * @param {String} code Input code.\r\n * @return {String} Returns code with </a> tags.\r\n */\r\nfunction processUrls(code)\r\n{\r\n\tvar gt = /(.*)((&gt;|&lt;).*)/;\r\n\t\r\n\treturn code.replace(sh.regexLib.url, function(m)\r\n\t{\r\n\t\tvar suffix = '',\r\n\t\t\tmatch = null\r\n\t\t\t;\r\n\t\t\r\n\t\t// We include &lt; and &gt; in the URL for the common cases like <http://google.com>\r\n\t\t// The problem is that they get transformed into &lt;http://google.com&gt;\r\n\t\t// Where as &gt; easily looks like part of the URL string.\r\n\t\r\n\t\tif (match = gt.exec(m))\r\n\t\t{\r\n\t\t\tm = match[1];\r\n\t\t\tsuffix = match[2];\r\n\t\t}\r\n\t\t\r\n\t\treturn '<a href=\"' + m + '\">' + m + '</a>' + suffix;\r\n\t});\r\n};\r\n\r\n/**\r\n * Finds all <SCRIPT TYPE=\"syntaxhighlighter\" /> elementss.\r\n * @return {Array} Returns array of all found SyntaxHighlighter tags.\r\n */\r\nfunction getSyntaxHighlighterScriptTags()\r\n{\r\n\tvar tags = document.getElementsByTagName('script'),\r\n\t\tresult = []\r\n\t\t;\r\n\t\r\n\tfor (var i = 0; i < tags.length; i++)\r\n\t\tif (tags[i].type == 'syntaxhighlighter')\r\n\t\t\tresult.push(tags[i]);\r\n\t\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used\r\n * there in most cases for XHTML compliance.\r\n * @param {String} original\tInput code.\r\n * @return {String} Returns code without leading <![CDATA[]]> tags.\r\n */\r\nfunction stripCData(original)\r\n{\r\n\tvar left = '<![CDATA[',\r\n\t\tright = ']]>',\r\n\t\t// for some reason IE inserts some leading blanks here\r\n\t\tcopy = trim(original),\r\n\t\tchanged = false,\r\n\t\tleftLength = left.length,\r\n\t\trightLength = right.length\r\n\t\t;\r\n\t\r\n\tif (copy.indexOf(left) == 0)\r\n\t{\r\n\t\tcopy = copy.substring(leftLength);\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\tvar copyLength = copy.length;\r\n\t\r\n\tif (copy.indexOf(right) == copyLength - rightLength)\r\n\t{\r\n\t\tcopy = copy.substring(0, copyLength - rightLength);\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\treturn changed ? copy : original;\r\n};\r\n\r\n\r\n/**\r\n * Quick code mouse double click handler.\r\n */\r\nfunction quickCodeHandler(e)\r\n{\r\n\tvar target = e.target,\r\n\t\thighlighterDiv = findParentElement(target, '.syntaxhighlighter'),\r\n\t\tcontainer = findParentElement(target, '.container'),\r\n\t\ttextarea = document.createElement('textarea'),\r\n\t\thighlighter\r\n\t\t;\r\n\r\n\tif (!container || !highlighterDiv || findElement(container, 'textarea'))\r\n\t\treturn;\r\n\r\n\thighlighter = getHighlighterById(highlighterDiv.id);\r\n\t\r\n\t// add source class name\r\n\taddClass(highlighterDiv, 'source');\r\n\r\n\t// Have to go over each line and grab it's text, can't just do it on the\r\n\t// container because Firefox loses all \\n where as Webkit doesn't.\r\n\tvar lines = container.childNodes,\r\n\t\tcode = []\r\n\t\t;\r\n\t\r\n\tfor (var i = 0; i < lines.length; i++)\r\n\t\tcode.push(lines[i].innerText || lines[i].textContent);\r\n\t\r\n\t// using \\r instead of \\r or \\r\\n makes this work equally well on IE, FF and Webkit\r\n\tcode = code.join('\\r');\r\n\t\r\n\t// inject <textarea/> tag\r\n\ttextarea.appendChild(document.createTextNode(code));\r\n\tcontainer.appendChild(textarea);\r\n\t\r\n\t// preselect all text\r\n\ttextarea.focus();\r\n\ttextarea.select();\r\n\t\r\n\t// set up handler for lost focus\r\n\tattachEvent(textarea, 'blur', function(e)\r\n\t{\r\n\t\ttextarea.parentNode.removeChild(textarea);\r\n\t\tremoveClass(highlighterDiv, 'source');\r\n\t});\r\n};\r\n\r\n/**\r\n * Match object.\r\n */\r\nsh.Match = function(value, index, css)\r\n{\r\n\tthis.value = value;\r\n\tthis.index = index;\r\n\tthis.length = value.length;\r\n\tthis.css = css;\r\n\tthis.brushName = null;\r\n};\r\n\r\nsh.Match.prototype.toString = function()\r\n{\r\n\treturn this.value;\r\n};\r\n\r\n/**\r\n * Simulates HTML code with a scripting language embedded.\r\n * \r\n * @param {String} scriptBrushName Brush name of the scripting language.\r\n */\r\nsh.HtmlScript = function(scriptBrushName)\r\n{\r\n\tvar brushClass = findBrush(scriptBrushName),\r\n\t\tscriptBrush,\r\n\t\txmlBrush = new sh.brushes.Xml(),\r\n\t\tbracketsRegex = null,\r\n\t\tref = this,\r\n\t\tmethodsToExpose = 'getDiv getHtml init'.split(' ')\r\n\t\t;\r\n\r\n\tif (brushClass == null)\r\n\t\treturn;\r\n\t\r\n\tscriptBrush = new brushClass();\r\n\t\r\n\tfor(var i = 0; i < methodsToExpose.length; i++)\r\n\t\t// make a closure so we don't lose the name after i changes\r\n\t\t(function() {\r\n\t\t\tvar name = methodsToExpose[i];\r\n\t\t\t\r\n\t\t\tref[name] = function()\r\n\t\t\t{\r\n\t\t\t\treturn xmlBrush[name].apply(xmlBrush, arguments);\r\n\t\t\t};\r\n\t\t})();\r\n\t\r\n\tif (scriptBrush.htmlScript == null)\r\n\t{\r\n\t\talert(sh.config.strings.brushNotHtmlScript + scriptBrushName);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\txmlBrush.regexList.push(\r\n\t\t{ regex: scriptBrush.htmlScript.code, func: process }\r\n\t);\r\n\t\r\n\tfunction offsetMatches(matches, offset)\r\n\t{\r\n\t\tfor (var j = 0; j < matches.length; j++) \r\n\t\t\tmatches[j].index += offset;\r\n\t}\r\n\t\r\n\tfunction process(match, info)\r\n\t{\r\n\t\tvar code = match.code,\r\n\t\t\tmatches = [],\r\n\t\t\tregexList = scriptBrush.regexList,\r\n\t\t\toffset = match.index + match.left.length,\r\n\t\t\thtmlScript = scriptBrush.htmlScript,\r\n\t\t\tresult\r\n\t\t\t;\r\n\r\n\t\t// add all matches from the code\r\n\t\tfor (var i = 0; i < regexList.length; i++)\r\n\t\t{\r\n\t\t\tresult = getMatches(code, regexList[i]);\r\n\t\t\toffsetMatches(result, offset);\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\t// add left script bracket\r\n\t\tif (htmlScript.left != null && match.left != null)\r\n\t\t{\r\n\t\t\tresult = getMatches(match.left, htmlScript.left);\r\n\t\t\toffsetMatches(result, match.index);\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\t// add right script bracket\r\n\t\tif (htmlScript.right != null && match.right != null)\r\n\t\t{\r\n\t\t\tresult = getMatches(match.right, htmlScript.right);\r\n\t\t\toffsetMatches(result, match.index + match[0].lastIndexOf(match.right));\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\tfor (var j = 0; j < matches.length; j++)\r\n\t\t\tmatches[j].brushName = brushClass.brushName;\r\n\t\t\t\r\n\t\treturn matches;\r\n\t}\r\n};\r\n\r\n/**\r\n * Main Highlither class.\r\n * @constructor\r\n */\r\nsh.Highlighter = function()\r\n{\r\n\t// not putting any code in here because of the prototype inheritance\r\n};\r\n\r\nsh.Highlighter.prototype = {\r\n\t/**\r\n\t * Returns value of the parameter passed to the highlighter.\r\n\t * @param {String} name\t\t\t\tName of the parameter.\r\n\t * @param {Object} defaultValue\t\tDefault value.\r\n\t * @return {Object}\t\t\t\t\tReturns found value or default value otherwise.\r\n\t */\r\n\tgetParam: function(name, defaultValue)\r\n\t{\r\n\t\tvar result = this.params[name];\r\n\t\treturn toBoolean(result == null ? defaultValue : result);\r\n\t},\r\n\t\r\n\t/**\r\n\t * Shortcut to document.createElement().\r\n\t * @param {String} name\t\tName of the element to create (DIV, A, etc).\r\n\t * @return {HTMLElement}\tReturns new HTML element.\r\n\t */\r\n\tcreate: function(name)\r\n\t{\r\n\t\treturn document.createElement(name);\r\n\t},\r\n\t\r\n\t/**\r\n\t * Applies all regular expression to the code and stores all found\r\n\t * matches in the `this.matches` array.\r\n\t * @param {Array} regexList\t\tList of regular expressions.\r\n\t * @param {String} code\t\t\tSource code.\r\n\t * @return {Array}\t\t\t\tReturns list of matches.\r\n\t */\r\n\tfindMatches: function(regexList, code)\r\n\t{\r\n\t\tvar result = [];\r\n\t\t\r\n\t\tif (regexList != null)\r\n\t\t\tfor (var i = 0; i < regexList.length; i++) \r\n\t\t\t\t// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)\r\n\t\t\t\tif (typeof (regexList[i]) == \"object\")\r\n\t\t\t\t\tresult = result.concat(getMatches(code, regexList[i]));\r\n\t\t\r\n\t\t// sort and remove nested the matches\r\n\t\treturn this.removeNestedMatches(result.sort(matchesSortCallback));\r\n\t},\r\n\t\r\n\t/**\r\n\t * Checks to see if any of the matches are inside of other matches. \r\n\t * This process would get rid of highligted strings inside comments, \r\n\t * keywords inside strings and so on.\r\n\t */\r\n\tremoveNestedMatches: function(matches)\r\n\t{\r\n\t\t// Optimized by Jose Prado (http://joseprado.com)\r\n\t\tfor (var i = 0; i < matches.length; i++) \r\n\t\t{ \r\n\t\t\tif (matches[i] === null)\r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\tvar itemI = matches[i],\r\n\t\t\t\titemIEndPos = itemI.index + itemI.length\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tfor (var j = i + 1; j < matches.length && matches[i] !== null; j++) \r\n\t\t\t{\r\n\t\t\t\tvar itemJ = matches[j];\r\n\t\t\t\t\r\n\t\t\t\tif (itemJ === null) \r\n\t\t\t\t\tcontinue;\r\n\t\t\t\telse if (itemJ.index > itemIEndPos) \r\n\t\t\t\t\tbreak;\r\n\t\t\t\telse if (itemJ.index == itemI.index && itemJ.length > itemI.length)\r\n\t\t\t\t\tmatches[i] = null;\r\n\t\t\t\telse if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) \r\n\t\t\t\t\tmatches[j] = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn matches;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Creates an array containing integer line numbers starting from the 'first-line' param.\r\n\t * @return {Array} Returns array of integers.\r\n\t */\r\n\tfigureOutLineNumbers: function(code)\r\n\t{\r\n\t\tvar lines = [],\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line'))\r\n\t\t\t;\r\n\t\t\r\n\t\teachLine(code, function(line, index)\r\n\t\t{\r\n\t\t\tlines.push(index + firstLine);\r\n\t\t});\r\n\t\t\r\n\t\treturn lines;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Determines if specified line number is in the highlighted list.\r\n\t */\r\n\tisLineHighlighted: function(lineNumber)\r\n\t{\r\n\t\tvar list = this.getParam('highlight', []);\r\n\t\t\r\n\t\tif (typeof(list) != 'object' && list.push == null) \r\n\t\t\tlist = [ list ];\r\n\t\t\r\n\t\treturn indexOf(list, lineNumber.toString()) != -1;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for a single line of code while determining alternating line style.\r\n\t * @param {Integer} lineNumber\tLine number.\r\n\t * @param {String} code Line\tHTML markup.\r\n\t * @return {String}\t\t\t\tReturns HTML markup.\r\n\t */\r\n\tgetLineHtml: function(lineIndex, lineNumber, code)\r\n\t{\r\n\t\tvar classes = [\r\n\t\t\t'line',\r\n\t\t\t'number' + lineNumber,\r\n\t\t\t'index' + lineIndex,\r\n\t\t\t'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()\r\n\t\t];\r\n\t\t\r\n\t\tif (this.isLineHighlighted(lineNumber))\r\n\t\t \tclasses.push('highlighted');\r\n\t\t\r\n\t\tif (lineNumber == 0)\r\n\t\t\tclasses.push('break');\r\n\t\t\t\r\n\t\treturn '<div class=\"' + classes.join(' ') + '\">' + code + '</div>';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for line number column.\r\n\t * @param {String} code\t\t\tComplete code HTML markup.\r\n\t * @param {Array} lineNumbers\tCalculated line numbers.\r\n\t * @return {String}\t\t\t\tReturns HTML markup.\r\n\t */\r\n\tgetLineNumbersHtml: function(code, lineNumbers)\r\n\t{\r\n\t\tvar html = '',\r\n\t\t\tcount = splitLines(code).length,\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line')),\r\n\t\t\tpad = this.getParam('pad-line-numbers')\r\n\t\t\t;\r\n\t\t\r\n\t\tif (pad == true)\r\n\t\t\tpad = (firstLine + count - 1).toString().length;\r\n\t\telse if (isNaN(pad) == true)\r\n\t\t\tpad = 0;\r\n\t\t\t\r\n\t\tfor (var i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tvar lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,\r\n\t\t\t\tcode = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)\r\n\t\t\t\t;\r\n\t\t\t\t\r\n\t\t\thtml += this.getLineHtml(i, lineNumber, code);\r\n\t\t}\r\n\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Splits block of text into individual DIV lines.\r\n\t * @param {String} code\t\t\tCode to highlight.\r\n\t * @param {Array} lineNumbers\tCalculated line numbers.\r\n\t * @return {String}\t\t\t\tReturns highlighted code in HTML form.\r\n\t */\r\n\tgetCodeLinesHtml: function(html, lineNumbers)\r\n\t{\r\n\t\thtml = trim(html);\r\n\t\t\r\n\t\tvar lines = splitLines(html),\r\n\t\t\tpadLength = this.getParam('pad-line-numbers'),\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line')),\r\n\t\t\thtml = '',\r\n\t\t\tbrushName = this.getParam('brush')\r\n\t\t\t;\r\n\r\n\t\tfor (var i = 0; i < lines.length; i++)\r\n\t\t{\r\n\t\t\tvar line = lines[i],\r\n\t\t\t\tindent = /^(&nbsp;|\\s)+/.exec(line),\r\n\t\t\t\tspaces = null,\r\n\t\t\t\tlineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;\r\n\t\t\t\t;\r\n\r\n\t\t\tif (indent != null)\r\n\t\t\t{\r\n\t\t\t\tspaces = indent[0].toString();\r\n\t\t\t\tline = line.substr(spaces.length);\r\n\t\t\t\tspaces = spaces.replace(' ', sh.config.space);\r\n\t\t\t}\r\n\r\n\t\t\tline = trim(line);\r\n\t\t\t\r\n\t\t\tif (line.length == 0)\r\n\t\t\t\tline = sh.config.space;\r\n\t\t\t\r\n\t\t\thtml += this.getLineHtml(\r\n\t\t\t\ti,\r\n\t\t\t\tlineNumber, \r\n\t\t\t\t(spaces != null ? '<code class=\"' + brushName + ' spaces\">' + spaces + '</code>' : '') + line\r\n\t\t\t);\r\n\t\t}\r\n\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Returns HTML for the table title or empty string if title is null.\r\n\t */\r\n\tgetTitleHtml: function(title)\r\n\t{\r\n\t\treturn title ? '<caption>' + title + '</caption>' : '';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Finds all matches in the source code.\r\n\t * @param {String} code\t\tSource code to process matches in.\r\n\t * @param {Array} matches\tDiscovered regex matches.\r\n\t * @return {String} Returns formatted HTML with processed mathes.\r\n\t */\r\n\tgetMatchesHtml: function(code, matches)\r\n\t{\r\n\t\tvar pos = 0, \r\n\t\t\tresult = '',\r\n\t\t\tbrushName = this.getParam('brush', '')\r\n\t\t\t;\r\n\t\t\r\n\t\tfunction getBrushNameCss(match)\r\n\t\t{\r\n\t\t\tvar result = match ? (match.brushName || brushName) : brushName;\r\n\t\t\treturn result ? result + ' ' : '';\r\n\t\t};\r\n\t\t\r\n\t\t// Finally, go through the final list of matches and pull the all\r\n\t\t// together adding everything in between that isn't a match.\r\n\t\tfor (var i = 0; i < matches.length; i++) \r\n\t\t{\r\n\t\t\tvar match = matches[i],\r\n\t\t\t\tmatchBrushName\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tif (match === null || match.length === 0) \r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\tmatchBrushName = getBrushNameCss(match);\r\n\t\t\t\r\n\t\t\tresult += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')\r\n\t\t\t\t\t+ wrapLinesWithCode(match.value, matchBrushName + match.css)\r\n\t\t\t\t\t;\r\n\r\n\t\t\tpos = match.index + match.length + (match.offset || 0);\r\n\t\t}\r\n\r\n\t\t// don't forget to add whatever's remaining in the string\r\n\t\tresult += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');\r\n\r\n\t\treturn result;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for the whole syntax highlighter.\r\n\t * @param {String} code Source code.\r\n\t * @return {String} Returns HTML markup.\r\n\t */\r\n\tgetHtml: function(code)\r\n\t{\r\n\t\tvar html = '',\r\n\t\t\tclasses = [ 'syntaxhighlighter' ],\r\n\t\t\ttabSize,\r\n\t\t\tmatches,\r\n\t\t\tlineNumbers\r\n\t\t\t;\r\n\t\t\r\n\t\t// process light mode\r\n\t\tif (this.getParam('light') == true)\r\n\t\t\tthis.params.toolbar = this.params.gutter = false;\r\n\r\n\t\tclassName = 'syntaxhighlighter';\r\n\r\n\t\tif (this.getParam('collapse') == true)\r\n\t\t\tclasses.push('collapsed');\r\n\t\t\r\n\t\tif ((gutter = this.getParam('gutter')) == false)\r\n\t\t\tclasses.push('nogutter');\r\n\r\n\t\t// add custom user style name\r\n\t\tclasses.push(this.getParam('class-name'));\r\n\r\n\t\t// add brush alias to the class name for custom CSS\r\n\t\tclasses.push(this.getParam('brush'));\r\n\r\n\t\tcode = trimFirstAndLastLines(code)\r\n\t\t\t.replace(/\\r/g, ' ') // IE lets these buggers through\r\n\t\t\t;\r\n\r\n\t\ttabSize = this.getParam('tab-size');\r\n\r\n\t\t// replace tabs with spaces\r\n\t\tcode = this.getParam('smart-tabs') == true\r\n\t\t\t? processSmartTabs(code, tabSize)\r\n\t\t\t: processTabs(code, tabSize)\r\n\t\t\t;\r\n\r\n\t\t// unindent code by the common indentation\r\n\t\tcode = unindent(code);\r\n\r\n\t\tif (gutter)\r\n\t\t\tlineNumbers = this.figureOutLineNumbers(code);\r\n\t\t\r\n\t\t// find matches in the code using brushes regex list\r\n\t\tmatches = this.findMatches(this.regexList, code);\r\n\t\t// processes found matches into the html\r\n\t\thtml = this.getMatchesHtml(code, matches);\r\n\t\t// finally, split all lines so that they wrap well\r\n\t\thtml = this.getCodeLinesHtml(html, lineNumbers);\r\n\r\n\t\t// finally, process the links\r\n\t\tif (this.getParam('auto-links'))\r\n\t\t\thtml = processUrls(html);\r\n\t\t\r\n\t\tif (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))\r\n\t\t\tclasses.push('ie');\r\n\t\t\r\n\t\thtml = \r\n\t\t\t'<div id=\"' + getHighlighterId(this.id) + '\" class=\"' + classes.join(' ') + '\">'\r\n\t\t\t\t+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')\r\n\t\t\t\t+ '<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">'\r\n\t\t\t\t\t+ this.getTitleHtml(this.getParam('title'))\r\n\t\t\t\t\t+ '<tbody>'\r\n\t\t\t\t\t\t+ '<tr>'\r\n\t\t\t\t\t\t\t+ (gutter ? '<td class=\"gutter\">' + this.getLineNumbersHtml(code) + '</td>' : '')\r\n\t\t\t\t\t\t\t+ '<td class=\"code\">'\r\n\t\t\t\t\t\t\t\t+ '<div class=\"container\">'\r\n\t\t\t\t\t\t\t\t\t+ html\r\n\t\t\t\t\t\t\t\t+ '</div>'\r\n\t\t\t\t\t\t\t+ '</td>'\r\n\t\t\t\t\t\t+ '</tr>'\r\n\t\t\t\t\t+ '</tbody>'\r\n\t\t\t\t+ '</table>'\r\n\t\t\t+ '</div>'\r\n\t\t\t;\r\n\t\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Highlights the code and returns complete HTML.\r\n\t * @param {String} code     Code to highlight.\r\n\t * @return {Element}        Returns container DIV element with all markup.\r\n\t */\r\n\tgetDiv: function(code)\r\n\t{\r\n\t\tif (code === null) \r\n\t\t\tcode = '';\r\n\t\t\r\n\t\tthis.code = code;\r\n\r\n\t\tvar div = this.create('div');\r\n\r\n\t\t// create main HTML\r\n\t\tdiv.innerHTML = this.getHtml(code);\r\n\t\t\r\n\t\t// set up click handlers\r\n\t\tif (this.getParam('toolbar'))\r\n\t\t\tattachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);\r\n\t\t\r\n\t\tif (this.getParam('quick-code'))\r\n\t\t\tattachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);\r\n\t\t\r\n\t\treturn div;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Initializes the highlighter/brush.\r\n\t *\r\n\t * Constructor isn't used for initialization so that nothing executes during necessary\r\n\t * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.\r\n\t *\r\n\t * @param {Hash} params Highlighter parameters.\r\n\t */\r\n\tinit: function(params)\r\n\t{\r\n\t\tthis.id = guid();\r\n\t\t\r\n\t\t// register this instance in the highlighters list\r\n\t\tstoreHighlighter(this);\r\n\t\t\r\n\t\t// local params take precedence over defaults\r\n\t\tthis.params = merge(sh.defaults, params || {})\r\n\t\t\r\n\t\t// process light mode\r\n\t\tif (this.getParam('light') == true)\r\n\t\t\tthis.params.toolbar = this.params.gutter = false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Converts space separated list of keywords into a regular expression string.\r\n\t * @param {String} str    Space separated keywords.\r\n\t * @return {String}       Returns regular expression string.\r\n\t */\r\n\tgetKeywords: function(str)\r\n\t{\r\n\t\tstr = str\r\n\t\t\t.replace(/^\\s+|\\s+$/g, '')\r\n\t\t\t.replace(/\\s+/g, '|')\r\n\t\t\t;\r\n\t\t\r\n\t\treturn '\\\\b(?:' + str + ')\\\\b';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Makes a brush compatible with the `html-script` functionality.\r\n\t * @param {Object} regexGroup Object containing `left` and `right` regular expressions.\r\n\t */\r\n\tforHtmlScript: function(regexGroup)\r\n\t{\r\n\t\tthis.htmlScript = {\r\n\t\t\tleft : { regex: regexGroup.left, css: 'script' },\r\n\t\t\tright : { regex: regexGroup.right, css: 'script' },\r\n\t\t\tcode : new XRegExp(\r\n\t\t\t\t\"(?<left>\" + regexGroup.left.source + \")\" +\r\n\t\t\t\t\"(?<code>.*?)\" +\r\n\t\t\t\t\"(?<right>\" + regexGroup.right.source + \")\",\r\n\t\t\t\t\"sgi\"\r\n\t\t\t\t)\r\n\t\t};\r\n\t}\r\n}; // end of Highlighter\r\n\r\nreturn sh;\r\n}(); // end of anonymous function\r\n\r\n// CommonJS\r\ntypeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;\r\n"]],"start1":0,"start2":0,"length1":0,"length2":45226}]],"length":45226,"saved":false}
