{"ts":1351661054146,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1351661165824,"patch":[[{"diffs":[[1,"/**\r\n * SyntaxHighlighter\r\n * http://alexgorbatchev.com/SyntaxHighlighter\r\n *\r\n * SyntaxHighlighter is donationware. If you are using it, please donate.\r\n * http://alexgorbatchev.com/SyntaxHighlighter/donate.html\r\n *\r\n * @version\r\n * 3.0.83 (July 02 2010)\r\n * \r\n * @copyright\r\n * Copyright (C) 2004-2010 Alex Gorbatchev.\r\n *\r\n * @license\r\n * Dual licensed under the MIT and GPL licenses.\r\n */\r\n//\r\n// Begin anonymous function. This is used to contain local scope variables without polutting global scope.\r\n//\r\nvar SyntaxHighlighter = function() { \r\n\r\n// CommonJS\r\nif (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')\r\n{\r\n    XRegExp = require('XRegExp').XRegExp;\r\n}\r\n\r\n// Shortcut object which will be assigned to the SyntaxHighlighter variable.\r\n// This is a shorthand for local reference in order to avoid long namespace \r\n// references to SyntaxHighlighter.whatever...\r\nvar sh = {\r\n\tdefaults : {\r\n\t\t/** Additional CSS class names to be added to highlighter elements. */\r\n\t\t'class-name' : '',\r\n\t\t\r\n\t\t/** First line number. */\r\n\t\t'first-line' : 1,\r\n\t\t\r\n\t\t/**\r\n\t\t * Pads line numbers. Possible values are:\r\n\t\t *\r\n\t\t *   false - don't pad line numbers.\r\n\t\t *   true  - automaticaly pad numbers with minimum required number of leading zeroes.\r\n\t\t *   [int] - length up to which pad line numbers.\r\n\t\t */\r\n\t\t'pad-line-numbers' : false,\r\n\t\t\r\n\t\t/** Lines to highlight. */\r\n\t\t'highlight' : null,\r\n\t\t\r\n\t\t/** Title to be displayed above the code block. */\r\n\t\t'title' : null,\r\n\t\t\r\n\t\t/** Enables or disables smart tabs. */\r\n\t\t'smart-tabs' : true,\r\n\t\t\r\n\t\t/** Gets or sets tab size. */\r\n\t\t'tab-size' : 4,\r\n\t\t\r\n\t\t/** Enables or disables gutter. */\r\n\t\t'gutter' : true,\r\n\t\t\r\n\t\t/** Enables or disables toolbar. */\r\n\t\t'toolbar' : true,\r\n\t\t\r\n\t\t/** Enables quick code copy and paste from double click. */\r\n\t\t'quick-code' : true,\r\n\t\t\r\n\t\t/** Forces code view to be collapsed. */\r\n\t\t'collapse' : false,\r\n\t\t\r\n\t\t/** Enables or disables automatic links. */\r\n\t\t'auto-links' : true,\r\n\t\t\r\n\t\t/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */\r\n\t\t'light' : false,\r\n\t\t\r\n\t\t'html-script' : false\r\n\t},\r\n\t\r\n\tconfig : {\r\n\t\tspace : '&nbsp;',\r\n\t\t\r\n\t\t/** Enables use of <SCRIPT type=\"syntaxhighlighter\" /> tags. */\r\n\t\tuseScriptTags : true,\r\n\t\t\r\n\t\t/** Blogger mode flag. */\r\n\t\tbloggerMode : false,\r\n\t\t\r\n\t\tstripBrs : false,\r\n\t\t\r\n\t\t/** Name of the tag that SyntaxHighlighter will automatically look for. */\r\n\t\ttagName : 'pre',\r\n\t\t\r\n\t\tstrings : {\r\n\t\t\texpandSource : 'expand source',\r\n\t\t\thelp : '?',\r\n\t\t\talert: 'SyntaxHighlighter\\n\\n',\r\n\t\t\tnoBrush : 'Can\\'t find brush for: ',\r\n\t\t\tbrushNotHtmlScript : 'Brush wasn\\'t configured for html-script option: ',\r\n\t\t\t\r\n\t\t\t// this is populated by the build script\r\n\t\t\taboutDialog : '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /><title>About SyntaxHighlighter</title></head><body style=\"font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;\"><div style=\"text-align:center;margin-top:1.5em;\"><div style=\"font-size:xx-large;\">SyntaxHighlighter</div><div style=\"font-size:.75em;margin-bottom:3em;\"><div>version 3.0.83 (July 02 2010)</div><div><a href=\"http://alexgorbatchev.com/SyntaxHighlighter\" target=\"_blank\" style=\"color:#005896\">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402\" style=\"color:#005896\">donate</a> to <br/>keep development active!</div></div></body></html>'\r\n\t\t}\r\n\t},\r\n\t\r\n\t/** Internal 'global' variables. */\r\n\tvars : {\r\n\t\tdiscoveredBrushes : null,\r\n\t\thighlighters : {}\r\n\t},\r\n\t\r\n\t/** This object is populated by user included external brush files. */\r\n\tbrushes : {},\r\n\r\n\t/** Common regular expressions. */\r\n\tregexLib : {\r\n\t\tmultiLineCComments\t\t\t: /\\/\\*[\\s\\S]*?\\*\\//gm,\r\n\t\tsingleLineCComments\t\t\t: /\\/\\/.*$/gm,\r\n\t\tsingleLinePerlComments\t\t: /#.*$/gm,\r\n\t\tdoubleQuotedString\t\t\t: /\"([^\\\\\"\\n]|\\\\.)*\"/g,\r\n\t\tsingleQuotedString\t\t\t: /'([^\\\\'\\n]|\\\\.)*'/g,\r\n\t\tmultiLineDoubleQuotedString\t: new XRegExp('\"([^\\\\\\\\\"]|\\\\\\\\.)*\"', 'gs'),\r\n\t\tmultiLineSingleQuotedString\t: new XRegExp(\"'([^\\\\\\\\']|\\\\\\\\.)*'\", 'gs'),\r\n\t\txmlComments\t\t\t\t\t: /(&lt;|<)!--[\\s\\S]*?--(&gt;|>)/gm,\r\n\t\turl\t\t\t\t\t\t\t: /\\w+:\\/\\/[\\w-.\\/?%&=:@;]*/g,\r\n\t\t\r\n\t\t/** <?= ?> tags. */\r\n\t\tphpScriptTags \t\t\t\t: { left: /(&lt;|<)\\?=?/g, right: /\\?(&gt;|>)/g },\r\n\t\t\r\n\t\t/** <%= %> tags. */\r\n\t\taspScriptTags\t\t\t\t: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },\r\n\t\t\r\n\t\t/** <script></script> tags. */\r\n\t\tscriptScriptTags\t\t\t: { left: /(&lt;|<)\\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\\/\\s*script\\s*(&gt;|>)/gi }\r\n\t},\r\n\r\n\ttoolbar: {\r\n\t\t/**\r\n\t\t * Generates HTML markup for the toolbar.\r\n\t\t * @param {Highlighter} highlighter Highlighter instance.\r\n\t\t * @return {String} Returns HTML markup.\r\n\t\t */\r\n\t\tgetHtml: function(highlighter)\r\n\t\t{\r\n\t\t\tvar html = '<div class=\"toolbar\">',\r\n\t\t\t\titems = sh.toolbar.items,\r\n\t\t\t\tlist = items.list\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tfunction defaultGetHtml(highlighter, name)\r\n\t\t\t{\r\n\t\t\t\treturn sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tfor (var i = 0; i < list.length; i++)\r\n\t\t\t\thtml += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);\r\n\t\t\t\r\n\t\t\thtml += '</div>';\r\n\t\t\t\r\n\t\t\treturn html;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Generates HTML markup for a regular button in the toolbar.\r\n\t\t * @param {Highlighter} highlighter Highlighter instance.\r\n\t\t * @param {String} commandName\t\tCommand name that would be executed.\r\n\t\t * @param {String} label\t\t\tLabel text to display.\r\n\t\t * @return {String}\t\t\t\t\tReturns HTML markup.\r\n\t\t */\r\n\t\tgetButtonHtml: function(highlighter, commandName, label)\r\n\t\t{\r\n\t\t\treturn '<span><a href=\"#\" class=\"toolbar_item'\r\n\t\t\t\t+ ' command_' + commandName\r\n\t\t\t\t+ ' ' + commandName\r\n\t\t\t\t+ '\">' + label + '</a></span>'\r\n\t\t\t\t;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Event handler for a toolbar anchor.\r\n\t\t */\r\n\t\thandler: function(e)\r\n\t\t{\r\n\t\t\tvar target = e.target,\r\n\t\t\t\tclassName = target.className || ''\r\n\t\t\t\t;\r\n\r\n\t\t\tfunction getValue(name)\r\n\t\t\t{\r\n\t\t\t\tvar r = new RegExp(name + '_(\\\\w+)'),\r\n\t\t\t\t\tmatch = r.exec(className)\r\n\t\t\t\t\t;\r\n\r\n\t\t\t\treturn match ? match[1] : null;\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),\r\n\t\t\t\tcommandName = getValue('command')\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\t// execute the toolbar command\r\n\t\t\tif (highlighter && commandName)\r\n\t\t\t\tsh.toolbar.items[commandName].execute(highlighter);\r\n\r\n\t\t\t// disable default A click behaviour\r\n\t\t\te.preventDefault();\r\n\t\t},\r\n\t\t\r\n\t\t/** Collection of toolbar items. */\r\n\t\titems : {\r\n\t\t\t// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.\r\n\t\t\tlist: ['expandSource', 'help'],\r\n\r\n\t\t\texpandSource: {\r\n\t\t\t\tgetHtml: function(highlighter)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (highlighter.getParam('collapse') != true)\r\n\t\t\t\t\t\treturn '';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tvar title = highlighter.getParam('title');\r\n\t\t\t\t\treturn sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);\r\n\t\t\t\t},\r\n\t\t\t\r\n\t\t\t\texecute: function(highlighter)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar div = getHighlighterDivById(highlighter.id);\r\n\t\t\t\t\tremoveClass(div, 'collapsed');\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t/** Command to display the about dialog window. */\r\n\t\t\thelp: {\r\n\t\t\t\texecute: function(highlighter)\r\n\t\t\t\t{\t\r\n\t\t\t\t\tvar wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),\r\n\t\t\t\t\t\tdoc = wnd.document\r\n\t\t\t\t\t\t;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdoc.write(sh.config.strings.aboutDialog);\r\n\t\t\t\t\tdoc.close();\r\n\t\t\t\t\twnd.focus();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Finds all elements on the page which should be processes by SyntaxHighlighter.\r\n\t *\r\n\t * @param {Object} globalParams\t\tOptional parameters which override element's \r\n\t * \t\t\t\t\t\t\t\t\tparameters. Only used if element is specified.\r\n\t * \r\n\t * @param {Object} element\tOptional element to highlight. If none is\r\n\t * \t\t\t\t\t\t\tprovided, all elements in the current document \r\n\t * \t\t\t\t\t\t\tare returned which qualify.\r\n\t *\r\n\t * @return {Array}\tReturns list of <code>{ target: DOMElement, params: Object }</code> objects.\r\n\t */\r\n\tfindElements: function(globalParams, element)\r\n\t{\r\n\t\tvar elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), \r\n\t\t\tconf = sh.config,\r\n\t\t\tresult = []\r\n\t\t\t;\r\n\r\n\t\t// support for <SCRIPT TYPE=\"syntaxhighlighter\" /> feature\r\n\t\tif (conf.useScriptTags)\r\n\t\t\telements = elements.concat(getSyntaxHighlighterScriptTags());\r\n\r\n\t\tif (elements.length === 0) \r\n\t\t\treturn result;\r\n\t\r\n\t\tfor (var i = 0; i < elements.length; i++) \r\n\t\t{\r\n\t\t\tvar item = {\r\n\t\t\t\ttarget: elements[i], \r\n\t\t\t\t// local params take precedence over globals\r\n\t\t\t\tparams: merge(globalParams, parseParams(elements[i].className))\r\n\t\t\t};\r\n\r\n\t\t\tif (item.params['brush'] == null)\r\n\t\t\t\tcontinue;\r\n\t\t\t\t\r\n\t\t\tresult.push(item);\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Shorthand to highlight all elements on the page that are marked as \r\n\t * SyntaxHighlighter source code.\r\n\t * \r\n\t * @param {Object} globalParams\t\tOptional parameters which override element's \r\n\t * \t\t\t\t\t\t\t\t\tparameters. Only used if element is specified.\r\n\t * \r\n\t * @param {Object} element\tOptional element to highlight. If none is\r\n\t * \t\t\t\t\t\t\tprovided, all elements in the current document \r\n\t * \t\t\t\t\t\t\tare highlighted.\r\n\t */ \r\n\thighlight: function(globalParams, element)\r\n\t{\r\n\t\tvar elements = this.findElements(globalParams, element),\r\n\t\t\tpropertyName = 'innerHTML', \r\n\t\t\thighlighter = null,\r\n\t\t\tconf = sh.config\r\n\t\t\t;\r\n\r\n\t\tif (elements.length === 0) \r\n\t\t\treturn;\r\n\t\r\n\t\tfor (var i = 0; i < elements.length; i++) \r\n\t\t{\r\n\t\t\tvar element = elements[i],\r\n\t\t\t\ttarget = element.target,\r\n\t\t\t\tparams = element.params,\r\n\t\t\t\tbrushName = params.brush,\r\n\t\t\t\tcode\r\n\t\t\t\t;\r\n\r\n\t\t\tif (brushName == null)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t// Instantiate a brush\r\n\t\t\tif (params['html-script'] == 'true' || sh.defaults['html-script'] == true) \r\n\t\t\t{\r\n\t\t\t\thighlighter = new sh.HtmlScript(brushName);\r\n\t\t\t\tbrushName = 'htmlscript';\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar brush = findBrush(brushName);\r\n\t\t\t\t\r\n\t\t\t\tif (brush)\r\n\t\t\t\t\thighlighter = new brush();\r\n\t\t\t\telse\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcode = target[propertyName];\r\n\t\t\t\r\n\t\t\t// remove CDATA from <SCRIPT/> tags if it's present\r\n\t\t\tif (conf.useScriptTags)\r\n\t\t\t\tcode = stripCData(code);\r\n\t\t\t\t\r\n\t\t\t// Inject title if the attribute is present\r\n\t\t\tif ((target.title || '') != '')\r\n\t\t\t\tparams.title = target.title;\r\n\t\t\t\t\r\n\t\t\tparams['brush'] = brushName;\r\n\t\t\thighlighter.init(params);\r\n\t\t\telement = highlighter.getDiv(code);\r\n\t\t\t\r\n\t\t\t// carry over ID\r\n\t\t\tif ((target.id || '') != '')\r\n\t\t\t\telement.id = target.id;\r\n\t\t\t\r\n\t\t\ttarget.parentNode.replaceChild(element, target);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Main entry point for the SyntaxHighlighter.\r\n\t * @param {Object} params Optional params to apply to all highlighted elements.\r\n\t */\r\n\tall: function(params)\r\n\t{\r\n\t\tattachEvent(\r\n\t\t\twindow,\r\n\t\t\t'load',\r\n\t\t\tfunction() { sh.highlight(params); }\r\n\t\t);\r\n\t}\r\n}; // end of sh\r\n\r\nsh['all']\t\t\t= sh.all;\r\nsh['highlight']\t\t= sh.highlight;\r\n\r\n/**\r\n * Checks if target DOM elements has specified CSS class.\r\n * @param {DOMElement} target Target DOM element to check.\r\n * @param {String} className Name of the CSS class to check for.\r\n * @return {Boolean} Returns true if class name is present, false otherwise.\r\n */\r\nfunction hasClass(target, className)\r\n{\r\n\treturn target.className.indexOf(className) != -1;\r\n};\r\n\r\n/**\r\n * Adds CSS class name to the target DOM element.\r\n * @param {DOMElement} target Target DOM element.\r\n * @param {String} className New CSS class to add.\r\n */\r\nfunction addClass(target, className)\r\n{\r\n\tif (!hasClass(target, className))\r\n\t\ttarget.className += ' ' + className;\r\n};\r\n\r\n/**\r\n * Removes CSS class name from the target DOM element.\r\n * @param {DOMElement} target Target DOM element.\r\n * @param {String} className CSS class to remove.\r\n */\r\nfunction removeClass(target, className)\r\n{\r\n\ttarget.className = target.className.replace(className, '');\r\n};\r\n\r\n/**\r\n * Converts the source to array object. Mostly used for function arguments and \r\n * lists returned by getElementsByTagName() which aren't Array objects.\r\n * @param {List} source Source list.\r\n * @return {Array} Returns array.\r\n */\r\nfunction toArray(source)\r\n{\r\n\tvar result = [];\r\n\t\r\n\tfor (var i = 0; i < source.length; i++) \r\n\t\tresult.push(source[i]);\r\n\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Splits block of text into lines.\r\n * @param {String} block Block of text.\r\n * @return {Array} Returns array of lines.\r\n */\r\nfunction splitLines(block)\r\n{\r\n\treturn block.split('\\n');\r\n}\r\n\r\n/**\r\n * Generates HTML ID for the highlighter.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {String} Returns HTML ID.\r\n */\r\nfunction getHighlighterId(id)\r\n{\r\n\tvar prefix = 'highlighter_';\r\n\treturn id.indexOf(prefix) == 0 ? id : prefix + id;\r\n};\r\n\r\n/**\r\n * Finds Highlighter instance by ID.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {Highlighter} Returns instance of the highlighter.\r\n */\r\nfunction getHighlighterById(id)\r\n{\r\n\treturn sh.vars.highlighters[getHighlighterId(id)];\r\n};\r\n\r\n/**\r\n * Finds highlighter's DIV container.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {Element} Returns highlighter's DIV element.\r\n */\r\nfunction getHighlighterDivById(id)\r\n{\r\n\treturn document.getElementById(getHighlighterId(id));\r\n};\r\n\r\n/**\r\n * Stores highlighter so that getHighlighterById() can do its thing. Each\r\n * highlighter must call this method to preserve itself.\r\n * @param {Highilghter} highlighter Highlighter instance.\r\n */\r\nfunction storeHighlighter(highlighter)\r\n{\r\n\tsh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;\r\n};\r\n\r\n/**\r\n * Looks for a child or parent node which has specified classname.\r\n * Equivalent to jQuery's $(container).find(\".className\")\r\n * @param {Element} target Target element.\r\n * @param {String} search Class name or node name to look for.\r\n * @param {Boolean} reverse If set to true, will go up the node tree instead of down.\r\n * @return {Element} Returns found child or parent element on null.\r\n */\r\nfunction findElement(target, search, reverse /* optional */)\r\n{\r\n\tif (target == null)\r\n\t\treturn null;\r\n\t\t\r\n\tvar nodes\t\t\t= reverse != true ? target.childNodes : [ target.parentNode ],\r\n\t\tpropertyToFind\t= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',\r\n\t\texpectedValue,\r\n\t\tfound\r\n\t\t;\r\n\r\n\texpectedValue = propertyToFind != 'nodeName'\r\n\t\t? search.substr(1)\r\n\t\t: search.toUpperCase()\r\n\t\t;\r\n\t\t\r\n\t// main return of the found node\r\n\tif ((target[propertyToFind] || '').indexOf(expectedValue) != -1)\r\n\t\treturn target;\r\n\t\r\n\tfor (var i = 0; nodes && i < nodes.length && found == null; i++)\r\n\t\tfound = findElement(nodes[i], search, reverse);\r\n\t\r\n\treturn found;\r\n};\r\n\r\n/**\r\n * Looks for a parent node which has specified classname.\r\n * This is an alias to <code>findElement(container, className, true)</code>.\r\n * @param {Element} target Target element.\r\n * @param {String} className Class name to look for.\r\n * @return {Element} Returns found parent element on null.\r\n */\r\nfunction findParentElement(target, className)\r\n{\r\n\treturn findElement(target, className, true);\r\n};\r\n\r\n/**\r\n * Finds an index of element in the array.\r\n * @ignore\r\n * @param {Object} searchElement\r\n * @param {Number} fromIndex\r\n * @return {Number} Returns index of element if found; -1 otherwise.\r\n */\r\nfunction indexOf(array, searchElement, fromIndex)\r\n{\r\n\tfromIndex = Math.max(fromIndex || 0, 0);\r\n\r\n\tfor (var i = fromIndex; i < array.length; i++)\r\n\t\tif(array[i] == searchElement)\r\n\t\t\treturn i;\r\n\t\r\n\treturn -1;\r\n};\r\n\r\n/**\r\n * Generates a unique element ID.\r\n */\r\nfunction guid(prefix)\r\n{\r\n\treturn (prefix || '') + Math.round(Math.random() * 1000000).toString();\r\n};\r\n\r\n/**\r\n * Merges two objects. Values from obj2 override values in obj1.\r\n * Function is NOT recursive and works only for one dimensional objects.\r\n * @param {Object} obj1 First object.\r\n * @param {Object} obj2 Second object.\r\n * @return {Object} Returns combination of both objects.\r\n */\r\nfunction merge(obj1, obj2)\r\n{\r\n\tvar result = {}, name;\r\n\r\n\tfor (name in obj1) \r\n\t\tresult[name] = obj1[name];\r\n\t\r\n\tfor (name in obj2) \r\n\t\tresult[name] = obj2[name];\r\n\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Attempts to convert string to boolean.\r\n * @param {String} value Input string.\r\n * @return {Boolean} Returns true if input was \"true\", false if input was \"false\" and value otherwise.\r\n */\r\nfunction toBoolean(value)\r\n{\r\n\tvar result = { \"true\" : true, \"false\" : false }[value];\r\n\treturn result == null ? value : result;\r\n};\r\n\r\n/**\r\n * Opens up a centered popup window.\r\n * @param {String} url\t\tURL to open in the window.\r\n * @param {String} name\t\tPopup name.\r\n * @param {int} width\t\tPopup width.\r\n * @param {int} height\t\tPopup height.\r\n * @param {String} options\twindow.open() options.\r\n * @return {Window}\t\t\tReturns window instance.\r\n */\r\nfunction popup(url, name, width, height, options)\r\n{\r\n\tvar x = (screen.width - width) / 2,\r\n\t\ty = (screen.height - height) / 2\r\n\t\t;\r\n\t\t\r\n\toptions +=\t', left=' + x + \r\n\t\t\t\t', top=' + y +\r\n\t\t\t\t', width=' + width +\r\n\t\t\t\t', height=' + height\r\n\t\t;\r\n\toptions = options.replace(/^,/, '');\r\n\r\n\tvar win = window.open(url, name, options);\r\n\twin.focus();\r\n\treturn win;\r\n};\r\n\r\n/**\r\n * Adds event handler to the target object.\r\n * @param {Object} obj\t\tTarget object.\r\n * @param {String} type\t\tName of the event.\r\n * @param {Function} func\tHandling function.\r\n */\r\nfunction attachEvent(obj, type, func, scope)\r\n{\r\n\tfunction handler(e)\r\n\t{\r\n\t\te = e || window.event;\r\n\t\t\r\n\t\tif (!e.target)\r\n\t\t{\r\n\t\t\te.target = e.srcElement;\r\n\t\t\te.preventDefault = function()\r\n\t\t\t{\r\n\t\t\t\tthis.returnValue = false;\r\n\t\t\t};\r\n\t\t}\r\n\t\t\t\r\n\t\tfunc.call(scope || window, e);\r\n\t};\r\n\t\r\n\tif (obj.attachEvent) \r\n\t{\r\n\t\tobj.attachEvent('on' + type, handler);\r\n\t}\r\n\telse \r\n\t{\r\n\t\tobj.addEventListener(type, handler, false);\r\n\t}\r\n};\r\n\r\n/**\r\n * Displays an alert.\r\n * @param {String} str String to display.\r\n */\r\nfunction alert(str)\r\n{\r\n\twindow.alert(sh.config.strings.alert + str);\r\n};\r\n\r\n/**\r\n * Finds a brush by its alias.\r\n *\r\n * @param {String} alias\t\tBrush alias.\r\n * @param {Boolean} showAlert\tSuppresses the alert if false.\r\n * @return {Brush}\t\t\t\tReturns bursh constructor if found, null otherwise.\r\n */\r\nfunction findBrush(alias, showAlert)\r\n{\r\n\tvar brushes = sh.vars.discoveredBrushes,\r\n\t\tresult = null\r\n\t\t;\r\n\t\r\n\tif (brushes == null) \r\n\t{\r\n\t\tbrushes = {};\r\n\t\t\r\n\t\t// Find all brushes\r\n\t\tfor (var brush in sh.brushes) \r\n\t\t{\r\n\t\t\tvar info = sh.brushes[brush],\r\n\t\t\t\taliases = info.aliases\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tif (aliases == null) \r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\t// keep the brush name\r\n\t\t\tinfo.brushName = brush.toLowerCase();\r\n\t\t\t\r\n\t\t\tfor (var i = 0; i < aliases.length; i++) \r\n\t\t\t\tbrushes[aliases[i]] = brush;\r\n\t\t}\r\n\t\t\r\n\t\tsh.vars.discoveredBrushes = brushes;\r\n\t}\r\n\t\r\n\tresult = sh.brushes[brushes[alias]];\r\n\r\n\tif (result == null && showAlert != false)\r\n\t\talert(sh.config.strings.noBrush + alias);\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Executes a callback on each line and replaces each line with result from the callback.\r\n * @param {Object} str\t\t\tInput string.\r\n * @param {Object} callback\t\tCallback function taking one string argument and returning a string.\r\n */\r\nfunction eachLine(str, callback)\r\n{\r\n\tvar lines = splitLines(str);\r\n\t\r\n\tfor (var i = 0; i < lines.length; i++)\r\n\t\tlines[i] = callback(lines[i], i);\r\n\t\t\r\n\treturn lines.join('\\n');\r\n};\r\n\r\n/**\r\n * This is a special trim which only removes first and last empty lines\r\n * and doesn't affect valid leading space on the first line.\r\n * \r\n * @param {String} str   Input string\r\n * @return {String}      Returns string without empty first and last lines.\r\n */\r\nfunction trimFirstAndLastLines(str)\r\n{\r\n\treturn str.replace(/^[ ]*[\\n]+|[\\n]*[ ]*$/g, '');\r\n};\r\n\r\n/**\r\n * Parses key/value pairs into hash object.\r\n * \r\n * Understands the following formats:\r\n * - name: word;\r\n * - name: [word, word];\r\n * - name: \"string\";\r\n * - name: 'string';\r\n * \r\n * For example:\r\n *   name1: value; name2: [value, value]; name3: 'value'\r\n *   \r\n * @param {String} str    Input string.\r\n * @return {Object}       Returns deserialized object.\r\n */\r\nfunction parseParams(str)\r\n{\r\n\tvar match, \r\n\t\tresult = {},\r\n\t\tarrayRegex = new XRegExp(\"^\\\\[(?<values>(.*?))\\\\]$\"),\r\n\t\tregex = new XRegExp(\r\n\t\t\t\"(?<name>[\\\\w-]+)\" +\r\n\t\t\t\"\\\\s*:\\\\s*\" +\r\n\t\t\t\"(?<value>\" +\r\n\t\t\t\t\"[\\\\w-%#]+|\" +\t\t// word\r\n\t\t\t\t\"\\\\[.*?\\\\]|\" +\t\t// [] array\r\n\t\t\t\t'\".*?\"|' +\t\t\t// \"\" string\r\n\t\t\t\t\"'.*?'\" +\t\t\t// '' string\r\n\t\t\t\")\\\\s*;?\",\r\n\t\t\t\"g\"\r\n\t\t)\r\n\t\t;\r\n\r\n\twhile ((match = regex.exec(str)) != null) \r\n\t{\r\n\t\tvar value = match.value\r\n\t\t\t.replace(/^['\"]|['\"]$/g, '') // strip quotes from end of strings\r\n\t\t\t;\r\n\t\t\r\n\t\t// try to parse array value\r\n\t\tif (value != null && arrayRegex.test(value))\r\n\t\t{\r\n\t\t\tvar m = arrayRegex.exec(value);\r\n\t\t\tvalue = m.values.length > 0 ? m.values.split(/\\s*,\\s*/) : [];\r\n\t\t}\r\n\t\t\r\n\t\tresult[match.name] = value;\r\n\t}\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Wraps each line of the string into <code/> tag with given style applied to it.\r\n * \r\n * @param {String} str   Input string.\r\n * @param {String} css   Style name to apply to the string.\r\n * @return {String}      Returns input string with each line surrounded by <span/> tag.\r\n */\r\nfunction wrapLinesWithCode(str, css)\r\n{\r\n\tif (str == null || str.length == 0 || str == '\\n') \r\n\t\treturn str;\r\n\r\n\tstr = str.replace(/</g, '&lt;');\r\n\r\n\t// Replace two or more sequential spaces with &nbsp; leaving last space untouched.\r\n\tstr = str.replace(/ {2,}/g, function(m)\r\n\t{\r\n\t\tvar spaces = '';\r\n\t\t\r\n\t\tfor (var i = 0; i < m.length - 1; i++)\r\n\t\t\tspaces += sh.config.space;\r\n\t\t\r\n\t\treturn spaces + ' ';\r\n\t});\r\n\r\n\t// Split each line and apply <span class=\"...\">...</span> to them so that\r\n\t// leading spaces aren't included.\r\n\tif (css != null) \r\n\t\tstr = eachLine(str, function(line)\r\n\t\t{\r\n\t\t\tif (line.length == 0) \r\n\t\t\t\treturn '';\r\n\t\t\t\r\n\t\t\tvar spaces = '';\r\n\t\t\t\r\n\t\t\tline = line.replace(/^(&nbsp;| )+/, function(s)\r\n\t\t\t{\r\n\t\t\t\tspaces = s;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (line.length == 0) \r\n\t\t\t\treturn spaces;\r\n\t\t\t\r\n\t\t\treturn spaces + '<code class=\"' + css + '\">' + line + '</code>';\r\n\t\t});\r\n\r\n\treturn str;\r\n};\r\n\r\n/**\r\n * Pads number with zeros until it's length is the same as given length.\r\n * \r\n * @param {Number} number\tNumber to pad.\r\n * @param {Number} length\tMax string length with.\r\n * @return {String}\t\t\tReturns a string padded with proper amount of '0'.\r\n */\r\nfunction padNumber(number, length)\r\n{\r\n\tvar result = number.toString();\r\n\t\r\n\twhile (result.length < length)\r\n\t\tresult = '0' + result;\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Replaces tabs with spaces.\r\n * \r\n * @param {String} code\t\tSource code.\r\n * @param {Number} tabSize\tSize of the tab.\r\n * @return {String}\t\t\tReturns code with all tabs replaces by spaces.\r\n */\r\nfunction processTabs(code, tabSize)\r\n{\r\n\tvar tab = '';\r\n\t\r\n\tfor (var i = 0; i < tabSize; i++)\r\n\t\ttab += ' ';\r\n\r\n\treturn code.replace(/\\t/g, tab);\r\n};\r\n\r\n/**\r\n * Replaces tabs with smart spaces.\r\n * \r\n * @param {String} code    Code to fix the tabs in.\r\n * @param {Number} tabSize Number of spaces in a column.\r\n * @return {String}        Returns code with all tabs replaces with roper amount of spaces.\r\n */\r\nfunction processSmartTabs(code, tabSize)\r\n{\r\n\tvar lines = splitLines(code),\r\n\t\ttab = '\\t',\r\n\t\tspaces = ''\r\n\t\t;\r\n\t\r\n\t// Create a string with 1000 spaces to copy spaces from... \r\n\t// It's assumed that there would be no indentation longer than that.\r\n\tfor (var i = 0; i < 50; i++) \r\n\t\tspaces += '                    '; // 20 spaces * 50\r\n\t\t\t\r\n\t// This function inserts specified amount of spaces in the string\r\n\t// where a tab is while removing that given tab.\r\n\tfunction insertSpaces(line, pos, count)\r\n\t{\r\n\t\treturn line.substr(0, pos)\r\n\t\t\t+ spaces.substr(0, count)\r\n\t\t\t+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab\r\n\t\t\t;\r\n\t};\r\n\r\n\t// Go through all the lines and do the 'smart tabs' magic.\r\n\tcode = eachLine(code, function(line)\r\n\t{\r\n\t\tif (line.indexOf(tab) == -1) \r\n\t\t\treturn line;\r\n\t\t\r\n\t\tvar pos = 0;\r\n\t\t\r\n\t\twhile ((pos = line.indexOf(tab)) != -1) \r\n\t\t{\r\n\t\t\t// This is pretty much all there is to the 'smart tabs' logic.\r\n\t\t\t// Based on the position within the line and size of a tab,\r\n\t\t\t// calculate the amount of spaces we need to insert.\r\n\t\t\tvar spaces = tabSize - pos % tabSize;\r\n\t\t\tline = insertSpaces(line, pos, spaces);\r\n\t\t}\r\n\t\t\r\n\t\treturn line;\r\n\t});\r\n\t\r\n\treturn code;\r\n};\r\n\r\n/**\r\n * Performs various string fixes based on configuration.\r\n */\r\nfunction fixInputString(str)\r\n{\r\n\tvar br = /<br\\s*\\/?>|&lt;br\\s*\\/?&gt;/gi;\r\n\t\r\n\tif (sh.config.bloggerMode == true)\r\n\t\tstr = str.replace(br, '\\n');\r\n\r\n\tif (sh.config.stripBrs == true)\r\n\t\tstr = str.replace(br, '');\r\n\t\t\r\n\treturn str;\r\n};\r\n\r\n/**\r\n * Removes all white space at the begining and end of a string.\r\n * \r\n * @param {String} str   String to trim.\r\n * @return {String}      Returns string without leading and following white space characters.\r\n */\r\nfunction trim(str)\r\n{\r\n\treturn str.replace(/^\\s+|\\s+$/g, '');\r\n};\r\n\r\n/**\r\n * Unindents a block of text by the lowest common indent amount.\r\n * @param {String} str   Text to unindent.\r\n * @return {String}      Returns unindented text block.\r\n */\r\nfunction unindent(str)\r\n{\r\n\tvar lines = splitLines(fixInputString(str)),\r\n\t\tindents = new Array(),\r\n\t\tregex = /^\\s*/,\r\n\t\tmin = 1000\r\n\t\t;\r\n\t\r\n\t// go through every line and check for common number of indents\r\n\tfor (var i = 0; i < lines.length && min > 0; i++) \r\n\t{\r\n\t\tvar line = lines[i];\r\n\t\t\r\n\t\tif (trim(line).length == 0) \r\n\t\t\tcontinue;\r\n\t\t\r\n\t\tvar matches = regex.exec(line);\r\n\t\t\r\n\t\t// In the event that just one line doesn't have leading white space\r\n\t\t// we can't unindent anything, so bail completely.\r\n\t\tif (matches == null) \r\n\t\t\treturn str;\r\n\t\t\t\r\n\t\tmin = Math.min(matches[0].length, min);\r\n\t}\r\n\t\r\n\t// trim minimum common number of white space from the begining of every line\r\n\tif (min > 0) \r\n\t\tfor (var i = 0; i < lines.length; i++) \r\n\t\t\tlines[i] = lines[i].substr(min);\r\n\t\r\n\treturn lines.join('\\n');\r\n};\r\n\r\n/**\r\n * Callback method for Array.sort() which sorts matches by\r\n * index position and then by length.\r\n * \r\n * @param {Match} m1\tLeft object.\r\n * @param {Match} m2    Right object.\r\n * @return {Number}     Returns -1, 0 or -1 as a comparison result.\r\n */\r\nfunction matchesSortCallback(m1, m2)\r\n{\r\n\t// sort matches by index first\r\n\tif(m1.index < m2.index)\r\n\t\treturn -1;\r\n\telse if(m1.index > m2.index)\r\n\t\treturn 1;\r\n\telse\r\n\t{\r\n\t\t// if index is the same, sort by length\r\n\t\tif(m1.length < m2.length)\r\n\t\t\treturn -1;\r\n\t\telse if(m1.length > m2.length)\r\n\t\t\treturn 1;\r\n\t}\r\n\t\r\n\treturn 0;\r\n};\r\n\r\n/**\r\n * Executes given regular expression on provided code and returns all\r\n * matches that are found.\r\n * \r\n * @param {String} code    Code to execute regular expression on.\r\n * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.\r\n * @return {Array}         Returns a list of Match objects.\r\n */ \r\nfunction getMatches(code, regexInfo)\r\n{\r\n\tfunction defaultAdd(match, regexInfo)\r\n\t{\r\n\t\treturn match[0];\r\n\t};\r\n\t\r\n\tvar index = 0,\r\n\t\tmatch = null,\r\n\t\tmatches = [],\r\n\t\tfunc = regexInfo.func ? regexInfo.func : defaultAdd\r\n\t\t;\r\n\t\r\n\twhile((match = regexInfo.regex.exec(code)) != null)\r\n\t{\r\n\t\tvar resultMatch = func(match, regexInfo);\r\n\t\t\r\n\t\tif (typeof(resultMatch) == 'string')\r\n\t\t\tresultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];\r\n\r\n\t\tmatches = matches.concat(resultMatch);\r\n\t}\r\n\t\r\n\treturn matches;\r\n};\r\n\r\n/**\r\n * Turns all URLs in the code into <a/> tags.\r\n * @param {String} code Input code.\r\n * @return {String} Returns code with </a> tags.\r\n */\r\nfunction processUrls(code)\r\n{\r\n\tvar gt = /(.*)((&gt;|&lt;).*)/;\r\n\t\r\n\treturn code.replace(sh.regexLib.url, function(m)\r\n\t{\r\n\t\tvar suffix = '',\r\n\t\t\tmatch = null\r\n\t\t\t;\r\n\t\t\r\n\t\t// We include &lt; and &gt; in the URL for the common cases like <http://google.com>\r\n\t\t// The problem is that they get transformed into &lt;http://google.com&gt;\r\n\t\t// Where as &gt; easily looks like part of the URL string.\r\n\t\r\n\t\tif (match = gt.exec(m))\r\n\t\t{\r\n\t\t\tm = match[1];\r\n\t\t\tsuffix = match[2];\r\n\t\t}\r\n\t\t\r\n\t\treturn '<a href=\"' + m + '\">' + m + '</a>' + suffix;\r\n\t});\r\n};\r\n\r\n/**\r\n * Finds all <SCRIPT TYPE=\"syntaxhighlighter\" /> elementss.\r\n * @return {Array} Returns array of all found SyntaxHighlighter tags.\r\n */\r\nfunction getSyntaxHighlighterScriptTags()\r\n{\r\n\tvar tags = document.getElementsByTagName('script'),\r\n\t\tresult = []\r\n\t\t;\r\n\t\r\n\tfor (var i = 0; i < tags.length; i++)\r\n\t\tif (tags[i].type == 'syntaxhighlighter')\r\n\t\t\tresult.push(tags[i]);\r\n\t\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used\r\n * there in most cases for XHTML compliance.\r\n * @param {String} original\tInput code.\r\n * @return {String} Returns code without leading <![CDATA[]]> tags.\r\n */\r\nfunction stripCData(original)\r\n{\r\n\tvar left = '<![CDATA[',\r\n\t\tright = ']]>',\r\n\t\t// for some reason IE inserts some leading blanks here\r\n\t\tcopy = trim(original),\r\n\t\tchanged = false,\r\n\t\tleftLength = left.length,\r\n\t\trightLength = right.length\r\n\t\t;\r\n\t\r\n\tif (copy.indexOf(left) == 0)\r\n\t{\r\n\t\tcopy = copy.substring(leftLength);\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\tvar copyLength = copy.length;\r\n\t\r\n\tif (copy.indexOf(right) == copyLength - rightLength)\r\n\t{\r\n\t\tcopy = copy.substring(0, copyLength - rightLength);\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\treturn changed ? copy : original;\r\n};\r\n\r\n\r\n/**\r\n * Quick code mouse double click handler.\r\n */\r\nfunction quickCodeHandler(e)\r\n{\r\n\tvar target = e.target,\r\n\t\thighlighterDiv = findParentElement(target, '.syntaxhighlighter'),\r\n\t\tcontainer = findParentElement(target, '.container'),\r\n\t\ttextarea = document.createElement('textarea'),\r\n\t\thighlighter\r\n\t\t;\r\n\r\n\tif (!container || !highlighterDiv || findElement(container, 'textarea'))\r\n\t\treturn;\r\n\r\n\thighlighter = getHighlighterById(highlighterDiv.id);\r\n\t\r\n\t// add source class name\r\n\taddClass(highlighterDiv, 'source');\r\n\r\n\t// Have to go over each line and grab it's text, can't just do it on the\r\n\t// container because Firefox loses all \\n where as Webkit doesn't.\r\n\tvar lines = container.childNodes,\r\n\t\tcode = []\r\n\t\t;\r\n\t\r\n\tfor (var i = 0; i < lines.length; i++)\r\n\t\tcode.push(lines[i].innerText || lines[i].textContent);\r\n\t\r\n\t// using \\r instead of \\r or \\r\\n makes this work equally well on IE, FF and Webkit\r\n\tcode = code.join('\\r');\r\n\t\r\n\t// inject <textarea/> tag\r\n\ttextarea.appendChild(document.createTextNode(code));\r\n\tcontainer.appendChild(textarea);\r\n\t\r\n\t// preselect all text\r\n\ttextarea.focus();\r\n\ttextarea.select();\r\n\t\r\n\t// set up handler for lost focus\r\n\tattachEvent(textarea, 'blur', function(e)\r\n\t{\r\n\t\ttextarea.parentNode.removeChild(textarea);\r\n\t\tremoveClass(highlighterDiv, 'source');\r\n\t});\r\n};\r\n\r\n/**\r\n * Match object.\r\n */\r\nsh.Match = function(value, index, css)\r\n{\r\n\tthis.value = value;\r\n\tthis.index = index;\r\n\tthis.length = value.length;\r\n\tthis.css = css;\r\n\tthis.brushName = null;\r\n};\r\n\r\nsh.Match.prototype.toString = function()\r\n{\r\n\treturn this.value;\r\n};\r\n\r\n/**\r\n * Simulates HTML code with a scripting language embedded.\r\n * \r\n * @param {String} scriptBrushName Brush name of the scripting language.\r\n */\r\nsh.HtmlScript = function(scriptBrushName)\r\n{\r\n\tvar brushClass = findBrush(scriptBrushName),\r\n\t\tscriptBrush,\r\n\t\txmlBrush = new sh.brushes.Xml(),\r\n\t\tbracketsRegex = null,\r\n\t\tref = this,\r\n\t\tmethodsToExpose = 'getDiv getHtml init'.split(' ')\r\n\t\t;\r\n\r\n\tif (brushClass == null)\r\n\t\treturn;\r\n\t\r\n\tscriptBrush = new brushClass();\r\n\t\r\n\tfor(var i = 0; i < methodsToExpose.length; i++)\r\n\t\t// make a closure so we don't lose the name after i changes\r\n\t\t(function() {\r\n\t\t\tvar name = methodsToExpose[i];\r\n\t\t\t\r\n\t\t\tref[name] = function()\r\n\t\t\t{\r\n\t\t\t\treturn xmlBrush[name].apply(xmlBrush, arguments);\r\n\t\t\t};\r\n\t\t})();\r\n\t\r\n\tif (scriptBrush.htmlScript == null)\r\n\t{\r\n\t\talert(sh.config.strings.brushNotHtmlScript + scriptBrushName);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\txmlBrush.regexList.push(\r\n\t\t{ regex: scriptBrush.htmlScript.code, func: process }\r\n\t);\r\n\t\r\n\tfunction offsetMatches(matches, offset)\r\n\t{\r\n\t\tfor (var j = 0; j < matches.length; j++) \r\n\t\t\tmatches[j].index += offset;\r\n\t}\r\n\t\r\n\tfunction process(match, info)\r\n\t{\r\n\t\tvar code = match.code,\r\n\t\t\tmatches = [],\r\n\t\t\tregexList = scriptBrush.regexList,\r\n\t\t\toffset = match.index + match.left.length,\r\n\t\t\thtmlScript = scriptBrush.htmlScript,\r\n\t\t\tresult\r\n\t\t\t;\r\n\r\n\t\t// add all matches from the code\r\n\t\tfor (var i = 0; i < regexList.length; i++)\r\n\t\t{\r\n\t\t\tresult = getMatches(code, regexList[i]);\r\n\t\t\toffsetMatches(result, offset);\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\t// add left script bracket\r\n\t\tif (htmlScript.left != null && match.left != null)\r\n\t\t{\r\n\t\t\tresult = getMatches(match.left, htmlScript.left);\r\n\t\t\toffsetMatches(result, match.index);\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\t// add right script bracket\r\n\t\tif (htmlScript.right != null && match.right != null)\r\n\t\t{\r\n\t\t\tresult = getMatches(match.right, htmlScript.right);\r\n\t\t\toffsetMatches(result, match.index + match[0].lastIndexOf(match.right));\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\tfor (var j = 0; j < matches.length; j++)\r\n\t\t\tmatches[j].brushName = brushClass.brushName;\r\n\t\t\t\r\n\t\treturn matches;\r\n\t}\r\n};\r\n\r\n/**\r\n * Main Highlither class.\r\n * @constructor\r\n */\r\nsh.Highlighter = function()\r\n{\r\n\t// not putting any code in here because of the prototype inheritance\r\n};\r\n\r\nsh.Highlighter.prototype = {\r\n\t/**\r\n\t * Returns value of the parameter passed to the highlighter.\r\n\t * @param {String} name\t\t\t\tName of the parameter.\r\n\t * @param {Object} defaultValue\t\tDefault value.\r\n\t * @return {Object}\t\t\t\t\tReturns found value or default value otherwise.\r\n\t */\r\n\tgetParam: function(name, defaultValue)\r\n\t{\r\n\t\tvar result = this.params[name];\r\n\t\treturn toBoolean(result == null ? defaultValue : result);\r\n\t},\r\n\t\r\n\t/**\r\n\t * Shortcut to document.createElement().\r\n\t * @param {String} name\t\tName of the element to create (DIV, A, etc).\r\n\t * @return {HTMLElement}\tReturns new HTML element.\r\n\t */\r\n\tcreate: function(name)\r\n\t{\r\n\t\treturn document.createElement(name);\r\n\t},\r\n\t\r\n\t/**\r\n\t * Applies all regular expression to the code and stores all found\r\n\t * matches in the `this.matches` array.\r\n\t * @param {Array} regexList\t\tList of regular expressions.\r\n\t * @param {String} code\t\t\tSource code.\r\n\t * @return {Array}\t\t\t\tReturns list of matches.\r\n\t */\r\n\tfindMatches: function(regexList, code)\r\n\t{\r\n\t\tvar result = [];\r\n\t\t\r\n\t\tif (regexList != null)\r\n\t\t\tfor (var i = 0; i < regexList.length; i++) \r\n\t\t\t\t// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)\r\n\t\t\t\tif (typeof (regexList[i]) == \"object\")\r\n\t\t\t\t\tresult = result.concat(getMatches(code, regexList[i]));\r\n\t\t\r\n\t\t// sort and remove nested the matches\r\n\t\treturn this.removeNestedMatches(result.sort(matchesSortCallback));\r\n\t},\r\n\t\r\n\t/**\r\n\t * Checks to see if any of the matches are inside of other matches. \r\n\t * This process would get rid of highligted strings inside comments, \r\n\t * keywords inside strings and so on.\r\n\t */\r\n\tremoveNestedMatches: function(matches)\r\n\t{\r\n\t\t// Optimized by Jose Prado (http://joseprado.com)\r\n\t\tfor (var i = 0; i < matches.length; i++) \r\n\t\t{ \r\n\t\t\tif (matches[i] === null)\r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\tvar itemI = matches[i],\r\n\t\t\t\titemIEndPos = itemI.index + itemI.length\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tfor (var j = i + 1; j < matches.length && matches[i] !== null; j++) \r\n\t\t\t{\r\n\t\t\t\tvar itemJ = matches[j];\r\n\t\t\t\t\r\n\t\t\t\tif (itemJ === null) \r\n\t\t\t\t\tcontinue;\r\n\t\t\t\telse if (itemJ.index > itemIEndPos) \r\n\t\t\t\t\tbreak;\r\n\t\t\t\telse if (itemJ.index == itemI.index && itemJ.length > itemI.length)\r\n\t\t\t\t\tmatches[i] = null;\r\n\t\t\t\telse if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) \r\n\t\t\t\t\tmatches[j] = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn matches;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Creates an array containing integer line numbers starting from the 'first-line' param.\r\n\t * @return {Array} Returns array of integers.\r\n\t */\r\n\tfigureOutLineNumbers: function(code)\r\n\t{\r\n\t\tvar lines = [],\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line'))\r\n\t\t\t;\r\n\t\t\r\n\t\teachLine(code, function(line, index)\r\n\t\t{\r\n\t\t\tlines.push(index + firstLine);\r\n\t\t});\r\n\t\t\r\n\t\treturn lines;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Determines if specified line number is in the highlighted list.\r\n\t */\r\n\tisLineHighlighted: function(lineNumber)\r\n\t{\r\n\t\tvar list = this.getParam('highlight', []);\r\n\t\t\r\n\t\tif (typeof(list) != 'object' && list.push == null) \r\n\t\t\tlist = [ list ];\r\n\t\t\r\n\t\treturn indexOf(list, lineNumber.toString()) != -1;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for a single line of code while determining alternating line style.\r\n\t * @param {Integer} lineNumber\tLine number.\r\n\t * @param {String} code Line\tHTML markup.\r\n\t * @return {String}\t\t\t\tReturns HTML markup.\r\n\t */\r\n\tgetLineHtml: function(lineIndex, lineNumber, code)\r\n\t{\r\n\t\tvar classes = [\r\n\t\t\t'line',\r\n\t\t\t'number' + lineNumber,\r\n\t\t\t'index' + lineIndex,\r\n\t\t\t'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()\r\n\t\t];\r\n\t\t\r\n\t\tif (this.isLineHighlighted(lineNumber))\r\n\t\t \tclasses.push('highlighted');\r\n\t\t\r\n\t\tif (lineNumber == 0)\r\n\t\t\tclasses.push('break');\r\n\t\t\t\r\n\t\treturn '<div class=\"' + classes.join(' ') + '\">' + code + '</div>';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for line number column.\r\n\t * @param {String} code\t\t\tComplete code HTML markup.\r\n\t * @param {Array} lineNumbers\tCalculated line numbers.\r\n\t * @return {String}\t\t\t\tReturns HTML markup.\r\n\t */\r\n\tgetLineNumbersHtml: function(code, lineNumbers)\r\n\t{\r\n\t\tvar html = '',\r\n\t\t\tcount = splitLines(code).length,\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line')),\r\n\t\t\tpad = this.getParam('pad-line-numbers')\r\n\t\t\t;\r\n\t\t\r\n\t\tif (pad == true)\r\n\t\t\tpad = (firstLine + count - 1).toString().length;\r\n\t\telse if (isNaN(pad) == true)\r\n\t\t\tpad = 0;\r\n\t\t\t\r\n\t\tfor (var i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tvar lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,\r\n\t\t\t\tcode = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)\r\n\t\t\t\t;\r\n\t\t\t\t\r\n\t\t\thtml += this.getLineHtml(i, lineNumber, code);\r\n\t\t}\r\n\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Splits block of text into individual DIV lines.\r\n\t * @param {String} code\t\t\tCode to highlight.\r\n\t * @param {Array} lineNumbers\tCalculated line numbers.\r\n\t * @return {String}\t\t\t\tReturns highlighted code in HTML form.\r\n\t */\r\n\tgetCodeLinesHtml: function(html, lineNumbers)\r\n\t{\r\n\t\thtml = trim(html);\r\n\t\t\r\n\t\tvar lines = splitLines(html),\r\n\t\t\tpadLength = this.getParam('pad-line-numbers'),\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line')),\r\n\t\t\thtml = '',\r\n\t\t\tbrushName = this.getParam('brush')\r\n\t\t\t;\r\n\r\n\t\tfor (var i = 0; i < lines.length; i++)\r\n\t\t{\r\n\t\t\tvar line = lines[i],\r\n\t\t\t\tindent = /^(&nbsp;|\\s)+/.exec(line),\r\n\t\t\t\tspaces = null,\r\n\t\t\t\tlineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;\r\n\t\t\t\t;\r\n\r\n\t\t\tif (indent != null)\r\n\t\t\t{\r\n\t\t\t\tspaces = indent[0].toString();\r\n\t\t\t\tline = line.substr(spaces.length);\r\n\t\t\t\tspaces = spaces.replace(' ', sh.config.space);\r\n\t\t\t}\r\n\r\n\t\t\tline = trim(line);\r\n\t\t\t\r\n\t\t\tif (line.length == 0)\r\n\t\t\t\tline = sh.config.space;\r\n\t\t\t\r\n\t\t\thtml += this.getLineHtml(\r\n\t\t\t\ti,\r\n\t\t\t\tlineNumber, \r\n\t\t\t\t(spaces != null ? '<code class=\"' + brushName + ' spaces\">' + spaces + '</code>' : '') + line\r\n\t\t\t);\r\n\t\t}\r\n\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Returns HTML for the table title or empty string if title is null.\r\n\t */\r\n\tgetTitleHtml: function(title)\r\n\t{\r\n\t\treturn title ? '<caption>' + title + '</caption>' : '';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Finds all matches in the source code.\r\n\t * @param {String} code\t\tSource code to process matches in.\r\n\t * @param {Array} matches\tDiscovered regex matches.\r\n\t * @return {String} Returns formatted HTML with processed mathes.\r\n\t */\r\n\tgetMatchesHtml: function(code, matches)\r\n\t{\r\n\t\tvar pos = 0, \r\n\t\t\tresult = '',\r\n\t\t\tbrushName = this.getParam('brush', '')\r\n\t\t\t;\r\n\t\t\r\n\t\tfunction getBrushNameCss(match)\r\n\t\t{\r\n\t\t\tvar result = match ? (match.brushName || brushName) : brushName;\r\n\t\t\treturn result ? result + ' ' : '';\r\n\t\t};\r\n\t\t\r\n\t\t// Finally, go through the final list of matches and pull the all\r\n\t\t// together adding everything in between that isn't a match.\r\n\t\tfor (var i = 0; i < matches.length; i++) \r\n\t\t{\r\n\t\t\tvar match = matches[i],\r\n\t\t\t\tmatchBrushName\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tif (match === null || match.length === 0) \r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\tmatchBrushName = getBrushNameCss(match);\r\n\t\t\t\r\n\t\t\tresult += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')\r\n\t\t\t\t\t+ wrapLinesWithCode(match.value, matchBrushName + match.css)\r\n\t\t\t\t\t;\r\n\r\n\t\t\tpos = match.index + match.length + (match.offset || 0);\r\n\t\t}\r\n\r\n\t\t// don't forget to add whatever's remaining in the string\r\n\t\tresult += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');\r\n\r\n\t\treturn result;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for the whole syntax highlighter.\r\n\t * @param {String} code Source code.\r\n\t * @return {String} Returns HTML markup.\r\n\t */\r\n\tgetHtml: function(code)\r\n\t{\r\n\t\tvar html = '',\r\n\t\t\tclasses = [ 'syntaxhighlighter' ],\r\n\t\t\ttabSize,\r\n\t\t\tmatches,\r\n\t\t\tlineNumbers\r\n\t\t\t;\r\n\t\t\r\n\t\t// process light mode\r\n\t\tif (this.getParam('light') == true)\r\n\t\t\tthis.params.toolbar = this.params.gutter = false;\r\n\r\n\t\tclassName = 'syntaxhighlighter';\r\n\r\n\t\tif (this.getParam('collapse') == true)\r\n\t\t\tclasses.push('collapsed');\r\n\t\t\r\n\t\tif ((gutter = this.getParam('gutter')) == false)\r\n\t\t\tclasses.push('nogutter');\r\n\r\n\t\t// add custom user style name\r\n\t\tclasses.push(this.getParam('class-name'));\r\n\r\n\t\t// add brush alias to the class name for custom CSS\r\n\t\tclasses.push(this.getParam('brush'));\r\n\r\n\t\tcode = trimFirstAndLastLines(code)\r\n\t\t\t.replace(/\\r/g, ' ') // IE lets these buggers through\r\n\t\t\t;\r\n\r\n\t\ttabSize = this.getParam('tab-size');\r\n\r\n\t\t// replace tabs with spaces\r\n\t\tcode = this.getParam('smart-tabs') == true\r\n\t\t\t? processSmartTabs(code, tabSize)\r\n\t\t\t: processTabs(code, tabSize)\r\n\t\t\t;\r\n\r\n\t\t// unindent code by the common indentation\r\n\t\tcode = unindent(code);\r\n\r\n\t\tif (gutter)\r\n\t\t\tlineNumbers = this.figureOutLineNumbers(code);\r\n\t\t\r\n\t\t// find matches in the code using brushes regex list\r\n\t\tmatches = this.findMatches(this.regexList, code);\r\n\t\t// processes found matches into the html\r\n\t\thtml = this.getMatchesHtml(code, matches);\r\n\t\t// finally, split all lines so that they wrap well\r\n\t\thtml = this.getCodeLinesHtml(html, lineNumbers);\r\n\r\n\t\t// finally, process the links\r\n\t\tif (this.getParam('auto-links'))\r\n\t\t\thtml = processUrls(html);\r\n\t\t\r\n\t\tif (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))\r\n\t\t\tclasses.push('ie');\r\n\t\t\r\n\t\thtml = \r\n\t\t\t'<div id=\"' + getHighlighterId(this.id) + '\" class=\"' + classes.join(' ') + '\">'\r\n\t\t\t\t+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')\r\n\t\t\t\t+ '<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">'\r\n\t\t\t\t\t+ this.getTitleHtml(this.getParam('title'))\r\n\t\t\t\t\t+ '<tbody>'\r\n\t\t\t\t\t\t+ '<tr>'\r\n\t\t\t\t\t\t\t+ (gutter ? '<td class=\"gutter\">' + this.getLineNumbersHtml(code) + '</td>' : '')\r\n\t\t\t\t\t\t\t+ '<td class=\"code\">'\r\n\t\t\t\t\t\t\t\t+ '<div class=\"container\">'\r\n\t\t\t\t\t\t\t\t\t+ html\r\n\t\t\t\t\t\t\t\t+ '</div>'\r\n\t\t\t\t\t\t\t+ '</td>'\r\n\t\t\t\t\t\t+ '</tr>'\r\n\t\t\t\t\t+ '</tbody>'\r\n\t\t\t\t+ '</table>'\r\n\t\t\t+ '</div>'\r\n\t\t\t;\r\n\t\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Highlights the code and returns complete HTML.\r\n\t * @param {String} code     Code to highlight.\r\n\t * @return {Element}        Returns container DIV element with all markup.\r\n\t */\r\n\tgetDiv: function(code)\r\n\t{\r\n\t\tif (code === null) \r\n\t\t\tcode = '';\r\n\t\t\r\n\t\tthis.code = code;\r\n\r\n\t\tvar div = this.create('div');\r\n\r\n\t\t// create main HTML\r\n\t\tdiv.innerHTML = this.getHtml(code);\r\n\t\t\r\n\t\t// set up click handlers\r\n\t\tif (this.getParam('toolbar'))\r\n\t\t\tattachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);\r\n\t\t\r\n\t\tif (this.getParam('quick-code'))\r\n\t\t\tattachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);\r\n\t\t\r\n\t\treturn div;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Initializes the highlighter/brush.\r\n\t *\r\n\t * Constructor isn't used for initialization so that nothing executes during necessary\r\n\t * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.\r\n\t *\r\n\t * @param {Hash} params Highlighter parameters.\r\n\t */\r\n\tinit: function(params)\r\n\t{\r\n\t\tthis.id = guid();\r\n\t\t\r\n\t\t// register this instance in the highlighters list\r\n\t\tstoreHighlighter(this);\r\n\t\t\r\n\t\t// local params take precedence over defaults\r\n\t\tthis.params = merge(sh.defaults, params || {})\r\n\t\t\r\n\t\t// process light mode\r\n\t\tif (this.getParam('light') == true)\r\n\t\t\tthis.params.toolbar = this.params.gutter = false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Converts space separated list of keywords into a regular expression string.\r\n\t * @param {String} str    Space separated keywords.\r\n\t * @return {String}       Returns regular expression string.\r\n\t */\r\n\tgetKeywords: function(str)\r\n\t{\r\n\t\tstr = str\r\n\t\t\t.replace(/^\\s+|\\s+$/g, '')\r\n\t\t\t.replace(/\\s+/g, '|')\r\n\t\t\t;\r\n\t\t\r\n\t\treturn '\\\\b(?:' + str + ')\\\\b';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Makes a brush compatible with the `html-script` functionality.\r\n\t * @param {Object} regexGroup Object containing `left` and `right` regular expressions.\r\n\t */\r\n\tforHtmlScript: function(regexGroup)\r\n\t{\r\n\t\tthis.htmlScript = {\r\n\t\t\tleft : { regex: regexGroup.left, css: 'script' },\r\n\t\t\tright : { regex: regexGroup.right, css: 'script' },\r\n\t\t\tcode : new XRegExp(\r\n\t\t\t\t\"(?<left>\" + regexGroup.left.source + \")\" +\r\n\t\t\t\t\"(?<code>.*?)\" +\r\n\t\t\t\t\"(?<right>\" + regexGroup.right.source + \")\",\r\n\t\t\t\t\"sgi\"\r\n\t\t\t\t)\r\n\t\t};\r\n\t}\r\n}; // end of Highlighter\r\n\r\nreturn sh;\r\n}(); // end of anonymous function\r\n\r\n// CommonJS\r\ntypeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;\r\n"]],"start1":0,"start2":0,"length1":0,"length2":45226}]],"length":45226,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351662219288,"patch":[[{"diffs":[[0,"*/\r\n"],[-1,"//\r\n// Begin anonymous function. This is used to contain local scope variables without polutting global scope.\r\n//\r\nvar SyntaxHighlighter = function() { \r\n\r\n// CommonJS\r\nif (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')\r\n{\r\n    XRegExp = require('XRegExp').XRegExp;\r\n}\r\n\r\n// Shortcut object which will be assigned to the SyntaxHighlighter variable.\r\n// This is a shorthand for local reference in order to avoid long namespace \r\n// references to SyntaxHighlighter.whatever...\r\nvar sh = {\r\n\tdefaults : {\r\n\t\t/** Additional CSS class names to be added to highlighter elements. */\r\n\t\t'class-name' : '',\r\n\t\t\r\n\t\t/** First line number. */\r\n\t\t'first-line' : 1,\r\n\t\t\r\n\t\t/**\r\n\t\t * Pads line numbers. Possible values are:\r\n\t\t *\r\n\t\t *   false - don't pad line numbers.\r\n\t\t *   true  - automaticaly pad numbers with minimum required number of leading zeroes.\r\n\t\t *   [int] - length up to which pad line numbers.\r\n\t\t */\r\n\t\t'pad-line-numbers' : false,\r\n\t\t\r\n\t\t/** Lines to highlight. */\r\n\t\t'highlight' : null,\r\n\t\t\r\n\t\t/** Title to be displayed above the code block. */\r\n\t\t'title' : null,\r\n\t\t\r\n\t\t/** Enables or disables smart tabs. */\r\n\t\t'smart-tabs' : true,\r\n\t\t\r\n\t\t/** Gets or sets tab size. */\r\n\t\t'tab-size' : 4,\r\n\t\t\r\n\t\t/** Enables or disables gutter. */\r\n\t\t'gutter' : true,\r\n\t\t\r\n\t\t/** Enables or disables toolbar. */\r\n\t\t'toolbar' : true,\r\n\t\t\r\n\t\t/** Enables quick code copy and paste from double click. */\r\n\t\t'quick-code' : true,\r\n\t\t\r\n\t\t/** Forces code view to be collapsed. */\r\n\t\t'collapse' : false,\r\n\t\t\r\n\t\t/** Enables or disables automatic links. */\r\n\t\t'auto-links' : true,\r\n\t\t\r\n\t\t/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */\r\n\t\t'light' : false,\r\n\t\t\r\n\t\t'html-script' : false\r\n\t},\r\n\t\r\n\tconfig : {\r\n\t\tspace : '&nbsp;',\r\n\t\t\r\n\t\t/** Enables use of <SCRIPT type=\"syntaxhighlighter\" /> tags. */\r\n\t\tuseScriptTags : true,\r\n\t\t\r\n\t\t/** Blogger mode flag. */\r\n\t\tbloggerMode : false,\r\n\t\t\r\n\t\tstripBrs : false,\r\n\t\t\r\n\t\t/** Name of the tag that SyntaxHighlighter will automatically look for. */\r\n\t\ttagName : 'pre',\r\n\t\t\r\n\t\tstrings : {\r\n\t\t\texpandSource : 'expand source',\r\n\t\t\thelp : '?',\r\n\t\t\talert: 'SyntaxHighlighter\\n\\n',\r\n\t\t\tnoBrush : 'Can\\'t find brush for: ',\r\n\t\t\tbrushNotHtmlScript : 'Brush wasn\\'t configured for html-script option: ',\r\n\t\t\t\r\n\t\t\t// this is populated by the build script\r\n\t\t\taboutDialog : '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"><html xmlns=\"http://www.w3.org/1999/xhtml\"><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /><title>About SyntaxHighlighter</title></head><body style=\"font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;\"><div style=\"text-align:center;margin-top:1.5em;\"><div style=\"font-size:xx-large;\">SyntaxHighlighter</div><div style=\"font-size:.75em;margin-bottom:3em;\"><div>version 3.0.83 (July 02 2010)</div><div><a href=\"http://alexgorbatchev.com/SyntaxHighlighter\" target=\"_blank\" style=\"color:#005896\">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402\" style=\"color:#005896\">donate</a> to <br/>keep development active!</div></div></body></html>'\r\n\t\t}\r\n\t},\r\n\t\r\n\t/** Internal 'global' variables. */\r\n\tvars : {\r\n\t\tdiscoveredBrushes : null,\r\n\t\thighlighters : {}\r\n\t},\r\n\t\r\n\t/** This object is populated by user included external brush files. */\r\n\tbrushes : {},\r\n\r\n\t/** Common regular expressions. */\r\n\tregexLib : {\r\n\t\tmultiLineCComments\t\t\t: /\\/\\*[\\s\\S]*?\\*\\//gm,\r\n\t\tsingleLineCComments\t\t\t: /\\/\\/.*$/gm,\r\n\t\tsingleLinePerlComments\t\t: /#.*$/gm,\r\n\t\tdoubleQuotedString\t\t\t: /\"([^\\\\\"\\n]|\\\\.)*\"/g,\r\n\t\tsingleQuotedString\t\t\t: /'([^\\\\'\\n]|\\\\.)*'/g,\r\n\t\tmultiLineDoubleQuotedString\t: new XRegExp('\"([^\\\\\\\\\"]|\\\\\\\\.)*\"', 'gs'),\r\n\t\tmultiLineSingleQuotedString\t: new XRegExp(\"'([^\\\\\\\\']|\\\\\\\\.)*'\", 'gs'),\r\n\t\txmlComments\t\t\t\t\t: /(&lt;|<)!--[\\s\\S]*?--(&gt;|>)/gm,\r\n\t\turl\t\t\t\t\t\t\t: /\\w+:\\/\\/[\\w-.\\/?%&=:@;]*/g,\r\n\t\t\r\n\t\t/** <?= ?> tags. */\r\n\t\tphpScriptTags \t\t\t\t: { left: /(&lt;|<)\\?=?/g, right: /\\?(&gt;|>)/g },\r\n\t\t\r\n\t\t/** <%= %> tags. */\r\n\t\taspScriptTags\t\t\t\t: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },\r\n\t\t\r\n\t\t/** <script></script> tags. */\r\n\t\tscriptScriptTags\t\t\t: { left: /(&lt;|<)\\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\\/\\s*script\\s*(&gt;|>)/gi }\r\n\t},\r\n\r\n\ttoolbar: {\r\n\t\t/**\r\n\t\t * Generates HTML markup for the toolbar.\r\n\t\t * @param {Highlighter} highlighter Highlighter instance.\r\n\t\t * @return {String} Returns HTML markup.\r\n\t\t */\r\n\t\tgetHtml: function(highlighter)\r\n\t\t{\r\n\t\t\tvar html = '<div class=\"toolbar\">',\r\n\t\t\t\titems = sh.toolbar.items,\r\n\t\t\t\tlist = items.list\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tfunction defaultGetHtml(highlighter, name)\r\n\t\t\t{\r\n\t\t\t\treturn sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tfor (var i = 0; i < list.length; i++)\r\n\t\t\t\thtml += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);\r\n\t\t\t\r\n\t\t\thtml += '</div>';\r\n\t\t\t\r\n\t\t\treturn html;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Generates HTML markup for a regular button in the toolbar.\r\n\t\t * @param {Highlighter} highlighter Highlighter instance.\r\n\t\t * @param {String} commandName\t\tCommand name that would be executed.\r\n\t\t * @param {String} label\t\t\tLabel text to display.\r\n\t\t * @return {String}\t\t\t\t\tReturns HTML markup.\r\n\t\t */\r\n\t\tgetButtonHtml: function(highlighter, commandName, label)\r\n\t\t{\r\n\t\t\treturn '<span><a href=\"#\" class=\"toolbar_item'\r\n\t\t\t\t+ ' command_' + commandName\r\n\t\t\t\t+ ' ' + commandName\r\n\t\t\t\t+ '\">' + label + '</a></span>'\r\n\t\t\t\t;\r\n\t\t},\r\n\t\t\r\n\t\t/**\r\n\t\t * Event handler for a toolbar anchor.\r\n\t\t */\r\n\t\thandler: function(e)\r\n\t\t{\r\n\t\t\tvar target = e.target,\r\n\t\t\t\tclassName = target.className || ''\r\n\t\t\t\t;\r\n\r\n\t\t\tfunction getValue(name)\r\n\t\t\t{\r\n\t\t\t\tvar r = new RegExp(name + '_(\\\\w+)'),\r\n\t\t\t\t\tmatch = r.exec(className)\r\n\t\t\t\t\t;\r\n\r\n\t\t\t\treturn match ? match[1] : null;\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),\r\n\t\t\t\tcommandName = getValue('command')\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\t// execute the toolbar command\r\n\t\t\tif (highlighter && commandName)\r\n\t\t\t\tsh.toolbar.items[commandName].execute(highlighter);\r\n\r\n\t\t\t// disable default A click behaviour\r\n\t\t\te.preventDefault();\r\n\t\t},\r\n\t\t\r\n\t\t/** Collection of toolbar items. */\r\n\t\titems : {\r\n\t\t\t// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.\r\n\t\t\tlist: ['expandSource', 'help'],\r\n\r\n\t\t\texpandSource: {\r\n\t\t\t\tgetHtml: function(highlighter)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (highlighter.getParam('collapse') != true)\r\n\t\t\t\t\t\treturn '';\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tvar title = highlighter.getParam('title');\r\n\t\t\t\t\treturn sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);\r\n\t\t\t\t},\r\n\t\t\t\r\n\t\t\t\texecute: function(highlighter)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar div = getHighlighterDivById(highlighter.id);\r\n\t\t\t\t\tremoveClass(div, 'collapsed');\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t/** Command to display the about dialog window. */\r\n\t\t\thelp: {\r\n\t\t\t\texecute: function(highlighter)\r\n\t\t\t\t{\t\r\n\t\t\t\t\tvar wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),\r\n\t\t\t\t\t\tdoc = wnd.document\r\n\t\t\t\t\t\t;\r\n\t\t\t\t\t\r\n\t\t\t\t\tdoc.write(sh.config.strings.aboutDialog);\r\n\t\t\t\t\tdoc.close();\r\n\t\t\t\t\twnd.focus();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Finds all elements on the page which should be processes by SyntaxHighlighter.\r\n\t *\r\n\t * @param {Object} globalParams\t\tOptional parameters which override element's \r\n\t * \t\t\t\t\t\t\t\t\tparameters. Only used if element is specified.\r\n\t * \r\n\t * @param {Object} element\tOptional element to highlight. If none is\r\n\t * \t\t\t\t\t\t\tprovided, all elements in the current document \r\n\t * \t\t\t\t\t\t\tare returned which qualify.\r\n\t *\r\n\t * @return {Array}\tReturns list of <code>{ target: DOMElement, params: Object }</code> objects.\r\n\t */\r\n\tfindElements: function(globalParams, element)\r\n\t{\r\n\t\tvar elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), \r\n\t\t\tconf = sh.config,\r\n\t\t\tresult = []\r\n\t\t\t;\r\n\r\n\t\t// support for <SCRIPT TYPE=\"syntaxhighlighter\" /> feature\r\n\t\tif (conf.useScriptTags)\r\n\t\t\telements = elements.concat(getSyntaxHighlighterScriptTags());\r\n\r\n\t\tif (elements.length === 0) \r\n\t\t\treturn result;\r\n\t\r\n\t\tfor (var i = 0; i < elements.length; i++) \r\n\t\t{\r\n\t\t\tvar item = {\r\n\t\t\t\ttarget: elements[i], \r\n\t\t\t\t// local params take precedence over globals\r\n\t\t\t\tparams: merge(globalParams, parseParams(elements[i].className))\r\n\t\t\t};\r\n\r\n\t\t\tif (item.params['brush'] == null)\r\n\t\t\t\tcontinue;\r\n\t\t\t\t\r\n\t\t\tresult.push(item);\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Shorthand to highlight all elements on the page that are marked as \r\n\t * SyntaxHighlighter source code.\r\n\t * \r\n\t * @param {Object} globalParams\t\tOptional parameters which override element's \r\n\t * \t\t\t\t\t\t\t\t\tparameters. Only used if element is specified.\r\n\t * \r\n\t * @param {Object} element\tOptional element to highlight. If none is\r\n\t * \t\t\t\t\t\t\tprovided, all elements in the current document \r\n\t * \t\t\t\t\t\t\tare highlighted.\r\n\t */ \r\n\thighlight: function(globalParams, element)\r\n\t{\r\n\t\tvar elements = this.findElements(globalParams, element),\r\n\t\t\tpropertyName = 'innerHTML', \r\n\t\t\thighlighter = null,\r\n\t\t\tconf = sh.config\r\n\t\t\t;\r\n\r\n\t\tif (elements.length === 0) \r\n\t\t\treturn;\r\n\t\r\n\t\tfor (var i = 0; i < elements.length; i++) \r\n\t\t{\r\n\t\t\tvar element = elements[i],\r\n\t\t\t\ttarget = element.target,\r\n\t\t\t\tparams = element.params,\r\n\t\t\t\tbrushName = params.brush,\r\n\t\t\t\tcode\r\n\t\t\t\t;\r\n\r\n\t\t\tif (brushName == null)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t// Instantiate a brush\r\n\t\t\tif (params['html-script'] == 'true' || sh.defaults['html-script'] == true) \r\n\t\t\t{\r\n\t\t\t\thighlighter = new sh.HtmlScript(brushName);\r\n\t\t\t\tbrushName = 'htmlscript';\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar brush = findBrush(brushName);\r\n\t\t\t\t\r\n\t\t\t\tif (brush)\r\n\t\t\t\t\thighlighter = new brush();\r\n\t\t\t\telse\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tcode = target[propertyName];\r\n\t\t\t\r\n\t\t\t// remove CDATA from <SCRIPT/> tags if it's present\r\n\t\t\tif (conf.useScriptTags)\r\n\t\t\t\tcode = stripCData(code);\r\n\t\t\t\t\r\n\t\t\t// Inject title if the attribute is present\r\n\t\t\tif ((target.title || '') != '')\r\n\t\t\t\tparams.title = target.title;\r\n\t\t\t\t\r\n\t\t\tparams['brush'] = brushName;\r\n\t\t\thighlighter.init(params);\r\n\t\t\telement = highlighter.getDiv(code);\r\n\t\t\t\r\n\t\t\t// carry over ID\r\n\t\t\tif ((target.id || '') != '')\r\n\t\t\t\telement.id = target.id;\r\n\t\t\t\r\n\t\t\ttarget.parentNode.replaceChild(element, target);\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Main entry point for the SyntaxHighlighter.\r\n\t * @param {Object} params Optional params to apply to all highlighted elements.\r\n\t */\r\n\tall: function(params)\r\n\t{\r\n\t\tattachEvent(\r\n\t\t\twindow,\r\n\t\t\t'load',\r\n\t\t\tfunction() { sh.highlight(params); }\r\n\t\t);\r\n\t}\r\n}; // end of sh\r\n\r\nsh['all']\t\t\t= sh.all;\r\nsh['highlight']\t\t= sh.highlight;\r\n\r\n/**\r\n * Checks if target DOM elements has specified CSS class.\r\n * @param {DOMElement} target Target DOM element to check.\r\n * @param {String} className Name of the CSS class to check for.\r\n * @return {Boolean} Returns true if class name is present, false otherwise.\r\n */\r\nfunction hasClass(target, className)\r\n{\r\n\treturn target.className.indexOf(className) != -1;\r\n};\r\n\r\n/**\r\n * Adds CSS class name to the target DOM element.\r\n * @param {DOMElement} target Target DOM element.\r\n * @param {String} className New CSS class to add.\r\n */\r\nfunction addClass(target, className)\r\n{\r\n\tif (!hasClass(target, className))\r\n\t\ttarget.className += ' ' + className;\r\n};\r\n\r\n/**\r\n * Removes CSS class name from the target DOM element.\r\n * @param {DOMElement} target Target DOM element.\r\n * @param {String} className CSS class to remove.\r\n */\r\nfunction removeClass(target, className)\r\n{\r\n\ttarget.className = target.className.replace(className, '');\r\n};\r\n\r\n/**\r\n * Converts the source to array object. Mostly used for function arguments and \r\n * lists returned by getElementsByTagName() which aren't Array objects.\r\n * @param {List} source Source list.\r\n * @return {Array} Returns array.\r\n */\r\nfunction toArray(source)\r\n{\r\n\tvar result = [];\r\n\t\r\n\tfor (var i = 0; i < source.length; i++) \r\n\t\tresult.push(source[i]);\r\n\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Splits block of text into lines.\r\n * @param {String} block Block of text.\r\n * @return {Array} Returns array of lines.\r\n */\r\nfunction splitLines(block)\r\n{\r\n\treturn block.split('\\n');\r\n}\r\n\r\n/**\r\n * Generates HTML ID for the highlighter.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {String} Returns HTML ID.\r\n */\r\nfunction getHighlighterId(id)\r\n{\r\n\tvar prefix = 'highlighter_';\r\n\treturn id.indexOf(prefix) == 0 ? id : prefix + id;\r\n};\r\n\r\n/**\r\n * Finds Highlighter instance by ID.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {Highlighter} Returns instance of the highlighter.\r\n */\r\nfunction getHighlighterById(id)\r\n{\r\n\treturn sh.vars.highlighters[getHighlighterId(id)];\r\n};\r\n\r\n/**\r\n * Finds highlighter's DIV container.\r\n * @param {String} highlighterId Highlighter ID.\r\n * @return {Element} Returns highlighter's DIV element.\r\n */\r\nfunction getHighlighterDivById(id)\r\n{\r\n\treturn document.getElementById(getHighlighterId(id));\r\n};\r\n\r\n/**\r\n * Stores highlighter so that getHighlighterById() can do its thing. Each\r\n * highlighter must call this method to preserve itself.\r\n * @param {Highilghter} highlighter Highlighter instance.\r\n */\r\nfunction storeHighlighter(highlighter)\r\n{\r\n\tsh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;\r\n};\r\n\r\n/**\r\n * Looks for a child or parent node which has specified classname.\r\n * Equivalent to jQuery's $(container).find(\".className\")\r\n * @param {Element} target Target element.\r\n * @param {String} search Class name or node name to look for.\r\n * @param {Boolean} reverse If set to true, will go up the node tree instead of down.\r\n * @return {Element} Returns found child or parent element on null.\r\n */\r\nfunction findElement(target, search, reverse /* optional */)\r\n{\r\n\tif (target == null)\r\n\t\treturn null;\r\n\t\t\r\n\tvar nodes\t\t\t= reverse != true ? target.childNodes : [ target.parentNode ],\r\n\t\tpropertyToFind\t= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',\r\n\t\texpectedValue,\r\n\t\tfound\r\n\t\t;\r\n\r\n\texpectedValue = propertyToFind != 'nodeName'\r\n\t\t? search.substr(1)\r\n\t\t: search.toUpperCase()\r\n\t\t;\r\n\t\t\r\n\t// main return of the found node\r\n\tif ((target[propertyToFind] || '').indexOf(expectedValue) != -1)\r\n\t\treturn target;\r\n\t\r\n\tfor (var i = 0; nodes && i < nodes.length && found == null; i++)\r\n\t\tfound = findElement(nodes[i], search, reverse);\r\n\t\r\n\treturn found;\r\n};\r\n\r\n/**\r\n * Looks for a parent node which has specified classname.\r\n * This is an alias to <code>findElement(container, className, true)</code>.\r\n * @param {Element} target Target element.\r\n * @param {String} className Class name to look for.\r\n * @return {Element} Returns found parent element on null.\r\n */\r\nfunction findParentElement(target, className)\r\n{\r\n\treturn findElement(target, className, true);\r\n};\r\n\r\n/**\r\n * Finds an index of element in the array.\r\n * @ignore\r\n * @param {Object} searchElement\r\n * @param {Number} fromIndex\r\n * @return {Number} Returns index of element if found; -1 otherwise.\r\n */\r\nfunction indexOf(array, searchElement, fromIndex)\r\n{\r\n\tfromIndex = Math.max(fromIndex || 0, 0);\r\n\r\n\tfor (var i = fromIndex; i < array.length; i++)\r\n\t\tif(array[i] == searchElement)\r\n\t\t\treturn i;\r\n\t\r\n\treturn -1;\r\n};\r\n\r\n/**\r\n * Generates a unique element ID.\r\n */\r\nfunction guid(prefix)\r\n{\r\n\treturn (prefix || '') + Math.round(Math.random() * 1000000).toString();\r\n};\r\n\r\n/**\r\n * Merges two objects. Values from obj2 override values in obj1.\r\n * Function is NOT recursive and works only for one dimensional objects.\r\n * @param {Object} obj1 First object.\r\n * @param {Object} obj2 Second object.\r\n * @return {Object} Returns combination of both objects.\r\n */\r\nfunction merge(obj1, obj2)\r\n{\r\n\tvar result = {}, name;\r\n\r\n\tfor (name in obj1) \r\n\t\tresult[name] = obj1[name];\r\n\t\r\n\tfor (name in obj2) \r\n\t\tresult[name] = obj2[name];\r\n\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Attempts to convert string to boolean.\r\n * @param {String} value Input string.\r\n * @return {Boolean} Returns true if input was \"true\", false if input was \"false\" and value otherwise.\r\n */\r\nfunction toBoolean(value)\r\n{\r\n\tvar result = { \"true\" : true, \"false\" : false }[value];\r\n\treturn result == null ? value : result;\r\n};\r\n\r\n/**\r\n * Opens up a centered popup window.\r\n * @param {String} url\t\tURL to open in the window.\r\n * @param {String} name\t\tPopup name.\r\n * @param {int} width\t\tPopup width.\r\n * @param {int} height\t\tPopup height.\r\n * @param {String} options\twindow.open() options.\r\n * @return {Window}\t\t\tReturns window instance.\r\n */\r\nfunction popup(url, name, width, height, options)\r\n{\r\n\tvar x = (screen.width - width) / 2,\r\n\t\ty = (screen.height - height) / 2\r\n\t\t;\r\n\t\t\r\n\toptions +=\t', left=' + x + \r\n\t\t\t\t', top=' + y +\r\n\t\t\t\t', width=' + width +\r\n\t\t\t\t', height=' + height\r\n\t\t;\r\n\toptions = options.replace(/^,/, '');\r\n\r\n\tvar win = window.open(url, name, options);\r\n\twin.focus();\r\n\treturn win;\r\n};\r\n\r\n/**\r\n * Adds event handler to the target object.\r\n * @param {Object} obj\t\tTarget object.\r\n * @param {String} type\t\tName of the event.\r\n * @param {Function} func\tHandling function.\r\n */\r\nfunction attachEvent(obj, type, func, scope)\r\n{\r\n\tfunction handler(e)\r\n\t{\r\n\t\te = e || window.event;\r\n\t\t\r\n\t\tif (!e.target)\r\n\t\t{\r\n\t\t\te.target = e.srcElement;\r\n\t\t\te.preventDefault = function()\r\n\t\t\t{\r\n\t\t\t\tthis.returnValue = false;\r\n\t\t\t};\r\n\t\t}\r\n\t\t\t\r\n\t\tfunc.call(scope || window, e);\r\n\t};\r\n\t\r\n\tif (obj.attachEvent) \r\n\t{\r\n\t\tobj.attachEvent('on' + type, handler);\r\n\t}\r\n\telse \r\n\t{\r\n\t\tobj.addEventListener(type, handler, false);\r\n\t}\r\n};\r\n\r\n/**\r\n * Displays an alert.\r\n * @param {String} str String to display.\r\n */\r\nfunction alert(str)\r\n{\r\n\twindow.alert(sh.config.strings.alert + str);\r\n};\r\n\r\n/**\r\n * Finds a brush by its alias.\r\n *\r\n * @param {String} alias\t\tBrush alias.\r\n * @param {Boolean} showAlert\tSuppresses the alert if false.\r\n * @return {Brush}\t\t\t\tReturns bursh constructor if found, null otherwise.\r\n */\r\nfunction findBrush(alias, showAlert)\r\n{\r\n\tvar brushes = sh.vars.discoveredBrushes,\r\n\t\tresult = null\r\n\t\t;\r\n\t\r\n\tif (brushes == null) \r\n\t{\r\n\t\tbrushes = {};\r\n\t\t\r\n\t\t// Find all brushes\r\n\t\tfor (var brush in sh.brushes) \r\n\t\t{\r\n\t\t\tvar info = sh.brushes[brush],\r\n\t\t\t\taliases = info.aliases\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tif (aliases == null) \r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\t// keep the brush name\r\n\t\t\tinfo.brushName = brush.toLowerCase();\r\n\t\t\t\r\n\t\t\tfor (var i = 0; i < aliases.length; i++) \r\n\t\t\t\tbrushes[aliases[i]] = brush;\r\n\t\t}\r\n\t\t\r\n\t\tsh.vars.discoveredBrushes = brushes;\r\n\t}\r\n\t\r\n\tresult = sh.brushes[brushes[alias]];\r\n\r\n\tif (result == null && showAlert != false)\r\n\t\talert(sh.config.strings.noBrush + alias);\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Executes a callback on each line and replaces each line with result from the callback.\r\n * @param {Object} str\t\t\tInput string.\r\n * @param {Object} callback\t\tCallback function taking one string argument and returning a string.\r\n */\r\nfunction eachLine(str, callback)\r\n{\r\n\tvar lines = splitLines(str);\r\n\t\r\n\tfor (var i = 0; i < lines.length; i++)\r\n\t\tlines[i] = callback(lines[i], i);\r\n\t\t\r\n\treturn lines.join('\\n');\r\n};\r\n\r\n/**\r\n * This is a special trim which only removes first and last empty lines\r\n * and doesn't affect valid leading space on the first line.\r\n * \r\n * @param {String} str   Input string\r\n * @return {String}      Returns string without empty first and last lines.\r\n */\r\nfunction trimFirstAndLastLines(str)\r\n{\r\n\treturn str.replace(/^[ ]*[\\n]+|[\\n]*[ ]*$/g, '');\r\n};\r\n\r\n/**\r\n * Parses key/value pairs into hash object.\r\n * \r\n * Understands the following formats:\r\n * - name: word;\r\n * - name: [word, word];\r\n * - name: \"string\";\r\n * - name: 'string';\r\n * \r\n * For example:\r\n *   name1: value; name2: [value, value]; name3: 'value'\r\n *   \r\n * @param {String} str    Input string.\r\n * @return {Object}       Returns deserialized object.\r\n */\r\nfunction parseParams(str)\r\n{\r\n\tvar match, \r\n\t\tresult = {},\r\n\t\tarrayRegex = new XRegExp(\"^\\\\[(?<values>(.*?))\\\\]$\"),\r\n\t\tregex = new XRegExp(\r\n\t\t\t\"(?<name>[\\\\w-]+)\" +\r\n\t\t\t\"\\\\s*:\\\\s*\" +\r\n\t\t\t\"(?<value>\" +\r\n\t\t\t\t\"[\\\\w-%#]+|\" +\t\t// word\r\n\t\t\t\t\"\\\\[.*?\\\\]|\" +\t\t// [] array\r\n\t\t\t\t'\".*?\"|' +\t\t\t// \"\" string\r\n\t\t\t\t\"'.*?'\" +\t\t\t// '' string\r\n\t\t\t\")\\\\s*;?\",\r\n\t\t\t\"g\"\r\n\t\t)\r\n\t\t;\r\n\r\n\twhile ((match = regex.exec(str)) != null) \r\n\t{\r\n\t\tvar value = match.value\r\n\t\t\t.replace(/^['\"]|['\"]$/g, '') // strip quotes from end of strings\r\n\t\t\t;\r\n\t\t\r\n\t\t// try to parse array value\r\n\t\tif (value != null && arrayRegex.test(value))\r\n\t\t{\r\n\t\t\tvar m = arrayRegex.exec(value);\r\n\t\t\tvalue = m.values.length > 0 ? m.values.split(/\\s*,\\s*/) : [];\r\n\t\t}\r\n\t\t\r\n\t\tresult[match.name] = value;\r\n\t}\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Wraps each line of the string into <code/> tag with given style applied to it.\r\n * \r\n * @param {String} str   Input string.\r\n * @param {String} css   Style name to apply to the string.\r\n * @return {String}      Returns input string with each line surrounded by <span/> tag.\r\n */\r\nfunction wrapLinesWithCode(str, css)\r\n{\r\n\tif (str == null || str.length == 0 || str == '\\n') \r\n\t\treturn str;\r\n\r\n\tstr = str.replace(/</g, '&lt;');\r\n\r\n\t// Replace two or more sequential spaces with &nbsp; leaving last space untouched.\r\n\tstr = str.replace(/ {2,}/g, function(m)\r\n\t{\r\n\t\tvar spaces = '';\r\n\t\t\r\n\t\tfor (var i = 0; i < m.length - 1; i++)\r\n\t\t\tspaces += sh.config.space;\r\n\t\t\r\n\t\treturn spaces + ' ';\r\n\t});\r\n\r\n\t// Split each line and apply <span class=\"...\">...</span> to them so that\r\n\t// leading spaces aren't included.\r\n\tif (css != null) \r\n\t\tstr = eachLine(str, function(line)\r\n\t\t{\r\n\t\t\tif (line.length == 0) \r\n\t\t\t\treturn '';\r\n\t\t\t\r\n\t\t\tvar spaces = '';\r\n\t\t\t\r\n\t\t\tline = line.replace(/^(&nbsp;| )+/, function(s)\r\n\t\t\t{\r\n\t\t\t\tspaces = s;\r\n\t\t\t\treturn '';\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif (line.length == 0) \r\n\t\t\t\treturn spaces;\r\n\t\t\t\r\n\t\t\treturn spaces + '<code class=\"' + css + '\">' + line + '</code>';\r\n\t\t});\r\n\r\n\treturn str;\r\n};\r\n\r\n/**\r\n * Pads number with zeros until it's length is the same as given length.\r\n * \r\n * @param {Number} number\tNumber to pad.\r\n * @param {Number} length\tMax string length with.\r\n * @return {String}\t\t\tReturns a string padded with proper amount of '0'.\r\n */\r\nfunction padNumber(number, length)\r\n{\r\n\tvar result = number.toString();\r\n\t\r\n\twhile (result.length < length)\r\n\t\tresult = '0' + result;\r\n\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Replaces tabs with spaces.\r\n * \r\n * @param {String} code\t\tSource code.\r\n * @param {Number} tabSize\tSize of the tab.\r\n * @return {String}\t\t\tReturns code with all tabs replaces by spaces.\r\n */\r\nfunction processTabs(code, tabSize)\r\n{\r\n\tvar tab = '';\r\n\t\r\n\tfor (var i = 0; i < tabSize; i++)\r\n\t\ttab += ' ';\r\n\r\n\treturn code.replace(/\\t/g, tab);\r\n};\r\n\r\n/**\r\n * Replaces tabs with smart spaces.\r\n * \r\n * @param {String} code    Code to fix the tabs in.\r\n * @param {Number} tabSize Number of spaces in a column.\r\n * @return {String}        Returns code with all tabs replaces with roper amount of spaces.\r\n */\r\nfunction processSmartTabs(code, tabSize)\r\n{\r\n\tvar lines = splitLines(code),\r\n\t\ttab = '\\t',\r\n\t\tspaces = ''\r\n\t\t;\r\n\t\r\n\t// Create a string with 1000 spaces to copy spaces from... \r\n\t// It's assumed that there would be no indentation longer than that.\r\n\tfor (var i = 0; i < 50; i++) \r\n\t\tspaces += '                    '; // 20 spaces * 50\r\n\t\t\t\r\n\t// This function inserts specified amount of spaces in the string\r\n\t// where a tab is while removing that given tab.\r\n\tfunction insertSpaces(line, pos, count)\r\n\t{\r\n\t\treturn line.substr(0, pos)\r\n\t\t\t+ spaces.substr(0, count)\r\n\t\t\t+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab\r\n\t\t\t;\r\n\t};\r\n\r\n\t// Go through all the lines and do the 'smart tabs' magic.\r\n\tcode = eachLine(code, function(line)\r\n\t{\r\n\t\tif (line.indexOf(tab) == -1) \r\n\t\t\treturn line;\r\n\t\t\r\n\t\tvar pos = 0;\r\n\t\t\r\n\t\twhile ((pos = line.indexOf(tab)) != -1) \r\n\t\t{\r\n\t\t\t// This is pretty much all there is to the 'smart tabs' logic.\r\n\t\t\t// Based on the position within the line and size of a tab,\r\n\t\t\t// calculate the amount of spaces we need to insert.\r\n\t\t\tvar spaces = tabSize - pos % tabSize;\r\n\t\t\tline = insertSpaces(line, pos, spaces);\r\n\t\t}\r\n\t\t\r\n\t\treturn line;\r\n\t});\r\n\t\r\n\treturn code;\r\n};\r\n\r\n/**\r\n * Performs various string fixes based on configuration.\r\n */\r\nfunction fixInputString(str)\r\n{\r\n\tvar br = /<br\\s*\\/?>|&lt;br\\s*\\/?&gt;/gi;\r\n\t\r\n\tif (sh.config.bloggerMode == true)\r\n\t\tstr = str.replace(br, '\\n');\r\n\r\n\tif (sh.config.stripBrs == true)\r\n\t\tstr = str.replace(br, '');\r\n\t\t\r\n\treturn str;\r\n};\r\n\r\n/**\r\n * Removes all white space at the begining and end of a string.\r\n * \r\n * @param {String} str   String to trim.\r\n * @return {String}      Returns string without leading and following white space characters.\r\n */\r\nfunction trim(str)\r\n{\r\n\treturn str.replace(/^\\s+|\\s+$/g, '');\r\n};\r\n\r\n/**\r\n * Unindents a block of text by the lowest common indent amount.\r\n * @param {String} str   Text to unindent.\r\n * @return {String}      Returns unindented text block.\r\n */\r\nfunction unindent(str)\r\n{\r\n\tvar lines = splitLines(fixInputString(str)),\r\n\t\tindents = new Array(),\r\n\t\tregex = /^\\s*/,\r\n\t\tmin = 1000\r\n\t\t;\r\n\t\r\n\t// go through every line and check for common number of indents\r\n\tfor (var i = 0; i < lines.length && min > 0; i++) \r\n\t{\r\n\t\tvar line = lines[i];\r\n\t\t\r\n\t\tif (trim(line).length == 0) \r\n\t\t\tcontinue;\r\n\t\t\r\n\t\tvar matches = regex.exec(line);\r\n\t\t\r\n\t\t// In the event that just one line doesn't have leading white space\r\n\t\t// we can't unindent anything, so bail completely.\r\n\t\tif (matches == null) \r\n\t\t\treturn str;\r\n\t\t\t\r\n\t\tmin = Math.min(matches[0].length, min);\r\n\t}\r\n\t\r\n\t// trim minimum common number of white space from the begining of every line\r\n\tif (min > 0) \r\n\t\tfor (var i = 0; i < lines.length; i++) \r\n\t\t\tlines[i] = lines[i].substr(min);\r\n\t\r\n\treturn lines.join('\\n');\r\n};\r\n\r\n/**\r\n * Callback method for Array.sort() which sorts matches by\r\n * index position and then by length.\r\n * \r\n * @param {Match} m1\tLeft object.\r\n * @param {Match} m2    Right object.\r\n * @return {Number}     Returns -1, 0 or -1 as a comparison result.\r\n */\r\nfunction matchesSortCallback(m1, m2)\r\n{\r\n\t// sort matches by index first\r\n\tif(m1.index < m2.index)\r\n\t\treturn -1;\r\n\telse if(m1.index > m2.index)\r\n\t\treturn 1;\r\n\telse\r\n\t{\r\n\t\t// if index is the same, sort by length\r\n\t\tif(m1.length < m2.length)\r\n\t\t\treturn -1;\r\n\t\telse if(m1.length > m2.length)\r\n\t\t\treturn 1;\r\n\t}\r\n\t\r\n\treturn 0;\r\n};\r\n\r\n/**\r\n * Executes given regular expression on provided code and returns all\r\n * matches that are found.\r\n * \r\n * @param {String} code    Code to execute regular expression on.\r\n * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.\r\n * @return {Array}         Returns a list of Match objects.\r\n */ \r\nfunction getMatches(code, regexInfo)\r\n{\r\n\tfunction defaultAdd(match, regexInfo)\r\n\t{\r\n\t\treturn match[0];\r\n\t};\r\n\t\r\n\tvar index = 0,\r\n\t\tmatch = null,\r\n\t\tmatches = [],\r\n\t\tfunc = regexInfo.func ? regexInfo.func : defaultAdd\r\n\t\t;\r\n\t\r\n\twhile((match = regexInfo.regex.exec(code)) != null)\r\n\t{\r\n\t\tvar resultMatch = func(match, regexInfo);\r\n\t\t\r\n\t\tif (typeof(resultMatch) == 'string')\r\n\t\t\tresultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];\r\n\r\n\t\tmatches = matches.concat(resultMatch);\r\n\t}\r\n\t\r\n\treturn matches;\r\n};\r\n\r\n/**\r\n * Turns all URLs in the code into <a/> tags.\r\n * @param {String} code Input code.\r\n * @return {String} Returns code with </a> tags.\r\n */\r\nfunction processUrls(code)\r\n{\r\n\tvar gt = /(.*)((&gt;|&lt;).*)/;\r\n\t\r\n\treturn code.replace(sh.regexLib.url, function(m)\r\n\t{\r\n\t\tvar suffix = '',\r\n\t\t\tmatch = null\r\n\t\t\t;\r\n\t\t\r\n\t\t// We include &lt; and &gt; in the URL for the common cases like <http://google.com>\r\n\t\t// The problem is that they get transformed into &lt;http://google.com&gt;\r\n\t\t// Where as &gt; easily looks like part of the URL string.\r\n\t\r\n\t\tif (match = gt.exec(m))\r\n\t\t{\r\n\t\t\tm = match[1];\r\n\t\t\tsuffix = match[2];\r\n\t\t}\r\n\t\t\r\n\t\treturn '<a href=\"' + m + '\">' + m + '</a>' + suffix;\r\n\t});\r\n};\r\n\r\n/**\r\n * Finds all <SCRIPT TYPE=\"syntaxhighlighter\" /> elementss.\r\n * @return {Array} Returns array of all found SyntaxHighlighter tags.\r\n */\r\nfunction getSyntaxHighlighterScriptTags()\r\n{\r\n\tvar tags = document.getElementsByTagName('script'),\r\n\t\tresult = []\r\n\t\t;\r\n\t\r\n\tfor (var i = 0; i < tags.length; i++)\r\n\t\tif (tags[i].type == 'syntaxhighlighter')\r\n\t\t\tresult.push(tags[i]);\r\n\t\t\t\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used\r\n * there in most cases for XHTML compliance.\r\n * @param {String} original\tInput code.\r\n * @return {String} Returns code without leading <![CDATA[]]> tags.\r\n */\r\nfunction stripCData(original)\r\n{\r\n\tvar left = '<![CDATA[',\r\n\t\tright = ']]>',\r\n\t\t// for some reason IE inserts some leading blanks here\r\n\t\tcopy = trim(original),\r\n\t\tchanged = false,\r\n\t\tleftLength = left.length,\r\n\t\trightLength = right.length\r\n\t\t;\r\n\t\r\n\tif (copy.indexOf(left) == 0)\r\n\t{\r\n\t\tcopy = copy.substring(leftLength);\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\tvar copyLength = copy.length;\r\n\t\r\n\tif (copy.indexOf(right) == copyLength - rightLength)\r\n\t{\r\n\t\tcopy = copy.substring(0, copyLength - rightLength);\r\n\t\tchanged = true;\r\n\t}\r\n\t\r\n\treturn changed ? copy : original;\r\n};\r\n\r\n\r\n/**\r\n * Quick code mouse double click handler.\r\n */\r\nfunction quickCodeHandler(e)\r\n{\r\n\tvar target = e.target,\r\n\t\thighlighterDiv = findParentElement(target, '.syntaxhighlighter'),\r\n\t\tcontainer = findParentElement(target, '.container'),\r\n\t\ttextarea = document.createElement('textarea'),\r\n\t\thighlighter\r\n\t\t;\r\n\r\n\tif (!container || !highlighterDiv || findElement(container, 'textarea'))\r\n\t\treturn;\r\n\r\n\thighlighter = getHighlighterById(highlighterDiv.id);\r\n\t\r\n\t// add source class name\r\n\taddClass(highlighterDiv, 'source');\r\n\r\n\t// Have to go over each line and grab it's text, can't just do it on the\r\n\t// container because Firefox loses all \\n where as Webkit doesn't.\r\n\tvar lines = container.childNodes,\r\n\t\tcode = []\r\n\t\t;\r\n\t\r\n\tfor (var i = 0; i < lines.length; i++)\r\n\t\tcode.push(lines[i].innerText || lines[i].textContent);\r\n\t\r\n\t// using \\r instead of \\r or \\r\\n makes this work equally well on IE, FF and Webkit\r\n\tcode = code.join('\\r');\r\n\t\r\n\t// inject <textarea/> tag\r\n\ttextarea.appendChild(document.createTextNode(code));\r\n\tcontainer.appendChild(textarea);\r\n\t\r\n\t// preselect all text\r\n\ttextarea.focus();\r\n\ttextarea.select();\r\n\t\r\n\t// set up handler for lost focus\r\n\tattachEvent(textarea, 'blur', function(e)\r\n\t{\r\n\t\ttextarea.parentNode.removeChild(textarea);\r\n\t\tremoveClass(highlighterDiv, 'source');\r\n\t});\r\n};\r\n\r\n/**\r\n * Match object.\r\n */\r\nsh.Match = function(value, index, css)\r\n{\r\n\tthis.value = value;\r\n\tthis.index = index;\r\n\tthis.length = value.length;\r\n\tthis.css = css;\r\n\tthis.brushName = null;\r\n};\r\n\r\nsh.Match.prototype.toString = function()\r\n{\r\n\treturn this.value;\r\n};\r\n\r\n/**\r\n * Simulates HTML code with a scripting language embedded.\r\n * \r\n * @param {String} scriptBrushName Brush name of the scripting language.\r\n */\r\nsh.HtmlScript = function(scriptBrushName)\r\n{\r\n\tvar brushClass = findBrush(scriptBrushName),\r\n\t\tscriptBrush,\r\n\t\txmlBrush = new sh.brushes.Xml(),\r\n\t\tbracketsRegex = null,\r\n\t\tref = this,\r\n\t\tmethodsToExpose = 'getDiv getHtml init'.split(' ')\r\n\t\t;\r\n\r\n\tif (brushClass == null)\r\n\t\treturn;\r\n\t\r\n\tscriptBrush = new brushClass();\r\n\t\r\n\tfor(var i = 0; i < methodsToExpose.length; i++)\r\n\t\t// make a closure so we don't lose the name after i changes\r\n\t\t(function() {\r\n\t\t\tvar name = methodsToExpose[i];\r\n\t\t\t\r\n\t\t\tref[name] = function()\r\n\t\t\t{\r\n\t\t\t\treturn xmlBrush[name].apply(xmlBrush, arguments);\r\n\t\t\t};\r\n\t\t})();\r\n\t\r\n\tif (scriptBrush.htmlScript == null)\r\n\t{\r\n\t\talert(sh.config.strings.brushNotHtmlScript + scriptBrushName);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\txmlBrush.regexList.push(\r\n\t\t{ regex: scriptBrush.htmlScript.code, func: process }\r\n\t);\r\n\t\r\n\tfunction offsetMatches(matches, offset)\r\n\t{\r\n\t\tfor (var j = 0; j < matches.length; j++) \r\n\t\t\tmatches[j].index += offset;\r\n\t}\r\n\t\r\n\tfunction process(match, info)\r\n\t{\r\n\t\tvar code = match.code,\r\n\t\t\tmatches = [],\r\n\t\t\tregexList = scriptBrush.regexList,\r\n\t\t\toffset = match.index + match.left.length,\r\n\t\t\thtmlScript = scriptBrush.htmlScript,\r\n\t\t\tresult\r\n\t\t\t;\r\n\r\n\t\t// add all matches from the code\r\n\t\tfor (var i = 0; i < regexList.length; i++)\r\n\t\t{\r\n\t\t\tresult = getMatches(code, regexList[i]);\r\n\t\t\toffsetMatches(result, offset);\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\t// add left script bracket\r\n\t\tif (htmlScript.left != null && match.left != null)\r\n\t\t{\r\n\t\t\tresult = getMatches(match.left, htmlScript.left);\r\n\t\t\toffsetMatches(result, match.index);\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\t// add right script bracket\r\n\t\tif (htmlScript.right != null && match.right != null)\r\n\t\t{\r\n\t\t\tresult = getMatches(match.right, htmlScript.right);\r\n\t\t\toffsetMatches(result, match.index + match[0].lastIndexOf(match.right));\r\n\t\t\tmatches = matches.concat(result);\r\n\t\t}\r\n\t\t\r\n\t\tfor (var j = 0; j < matches.length; j++)\r\n\t\t\tmatches[j].brushName = brushClass.brushName;\r\n\t\t\t\r\n\t\treturn matches;\r\n\t}\r\n};\r\n\r\n/**\r\n * Main Highlither class.\r\n * @constructor\r\n */\r\nsh.Highlighter = function()\r\n{\r\n\t// not putting any code in here because of the prototype inheritance\r\n};\r\n\r\nsh.Highlighter.prototype = {\r\n\t/**\r\n\t * Returns value of the parameter passed to the highlighter.\r\n\t * @param {String} name\t\t\t\tName of the parameter.\r\n\t * @param {Object} defaultValue\t\tDefault value.\r\n\t * @return {Object}\t\t\t\t\tReturns found value or default value otherwise.\r\n\t */\r\n\tgetParam: function(name, defaultValue)\r\n\t{\r\n\t\tvar result = this.params[name];\r\n\t\treturn toBoolean(result == null ? defaultValue : result);\r\n\t},\r\n\t\r\n\t/**\r\n\t * Shortcut to document.createElement().\r\n\t * @param {String} name\t\tName of the element to create (DIV, A, etc).\r\n\t * @return {HTMLElement}\tReturns new HTML element.\r\n\t */\r\n\tcreate: function(name)\r\n\t{\r\n\t\treturn document.createElement(name);\r\n\t},\r\n\t\r\n\t/**\r\n\t * Applies all regular expression to the code and stores all found\r\n\t * matches in the `this.matches` array.\r\n\t * @param {Array} regexList\t\tList of regular expressions.\r\n\t * @param {String} code\t\t\tSource code.\r\n\t * @return {Array}\t\t\t\tReturns list of matches.\r\n\t */\r\n\tfindMatches: function(regexList, code)\r\n\t{\r\n\t\tvar result = [];\r\n\t\t\r\n\t\tif (regexList != null)\r\n\t\t\tfor (var i = 0; i < regexList.length; i++) \r\n\t\t\t\t// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)\r\n\t\t\t\tif (typeof (regexList[i]) == \"object\")\r\n\t\t\t\t\tresult = result.concat(getMatches(code, regexList[i]));\r\n\t\t\r\n\t\t// sort and remove nested the matches\r\n\t\treturn this.removeNestedMatches(result.sort(matchesSortCallback));\r\n\t},\r\n\t\r\n\t/**\r\n\t * Checks to see if any of the matches are inside of other matches. \r\n\t * This process would get rid of highligted strings inside comments, \r\n\t * keywords inside strings and so on.\r\n\t */\r\n\tremoveNestedMatches: function(matches)\r\n\t{\r\n\t\t// Optimized by Jose Prado (http://joseprado.com)\r\n\t\tfor (var i = 0; i < matches.length; i++) \r\n\t\t{ \r\n\t\t\tif (matches[i] === null)\r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\tvar itemI = matches[i],\r\n\t\t\t\titemIEndPos = itemI.index + itemI.length\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tfor (var j = i + 1; j < matches.length && matches[i] !== null; j++) \r\n\t\t\t{\r\n\t\t\t\tvar itemJ = matches[j];\r\n\t\t\t\t\r\n\t\t\t\tif (itemJ === null) \r\n\t\t\t\t\tcontinue;\r\n\t\t\t\telse if (itemJ.index > itemIEndPos) \r\n\t\t\t\t\tbreak;\r\n\t\t\t\telse if (itemJ.index == itemI.index && itemJ.length > itemI.length)\r\n\t\t\t\t\tmatches[i] = null;\r\n\t\t\t\telse if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) \r\n\t\t\t\t\tmatches[j] = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn matches;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Creates an array containing integer line numbers starting from the 'first-line' param.\r\n\t * @return {Array} Returns array of integers.\r\n\t */\r\n\tfigureOutLineNumbers: function(code)\r\n\t{\r\n\t\tvar lines = [],\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line'))\r\n\t\t\t;\r\n\t\t\r\n\t\teachLine(code, function(line, index)\r\n\t\t{\r\n\t\t\tlines.push(index + firstLine);\r\n\t\t});\r\n\t\t\r\n\t\treturn lines;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Determines if specified line number is in the highlighted list.\r\n\t */\r\n\tisLineHighlighted: function(lineNumber)\r\n\t{\r\n\t\tvar list = this.getParam('highlight', []);\r\n\t\t\r\n\t\tif (typeof(list) != 'object' && list.push == null) \r\n\t\t\tlist = [ list ];\r\n\t\t\r\n\t\treturn indexOf(list, lineNumber.toString()) != -1;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for a single line of code while determining alternating line style.\r\n\t * @param {Integer} lineNumber\tLine number.\r\n\t * @param {String} code Line\tHTML markup.\r\n\t * @return {String}\t\t\t\tReturns HTML markup.\r\n\t */\r\n\tgetLineHtml: function(lineIndex, lineNumber, code)\r\n\t{\r\n\t\tvar classes = [\r\n\t\t\t'line',\r\n\t\t\t'number' + lineNumber,\r\n\t\t\t'index' + lineIndex,\r\n\t\t\t'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()\r\n\t\t];\r\n\t\t\r\n\t\tif (this.isLineHighlighted(lineNumber))\r\n\t\t \tclasses.push('highlighted');\r\n\t\t\r\n\t\tif (lineNumber == 0)\r\n\t\t\tclasses.push('break');\r\n\t\t\t\r\n\t\treturn '<div class=\"' + classes.join(' ') + '\">' + code + '</div>';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for line number column.\r\n\t * @param {String} code\t\t\tComplete code HTML markup.\r\n\t * @param {Array} lineNumbers\tCalculated line numbers.\r\n\t * @return {String}\t\t\t\tReturns HTML markup.\r\n\t */\r\n\tgetLineNumbersHtml: function(code, lineNumbers)\r\n\t{\r\n\t\tvar html = '',\r\n\t\t\tcount = splitLines(code).length,\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line')),\r\n\t\t\tpad = this.getParam('pad-line-numbers')\r\n\t\t\t;\r\n\t\t\r\n\t\tif (pad == true)\r\n\t\t\tpad = (firstLine + count - 1).toString().length;\r\n\t\telse if (isNaN(pad) == true)\r\n\t\t\tpad = 0;\r\n\t\t\t\r\n\t\tfor (var i = 0; i < count; i++)\r\n\t\t{\r\n\t\t\tvar lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,\r\n\t\t\t\tcode = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)\r\n\t\t\t\t;\r\n\t\t\t\t\r\n\t\t\thtml += this.getLineHtml(i, lineNumber, code);\r\n\t\t}\r\n\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Splits block of text into individual DIV lines.\r\n\t * @param {String} code\t\t\tCode to highlight.\r\n\t * @param {Array} lineNumbers\tCalculated line numbers.\r\n\t * @return {String}\t\t\t\tReturns highlighted code in HTML form.\r\n\t */\r\n\tgetCodeLinesHtml: function(html, lineNumbers)\r\n\t{\r\n\t\thtml = trim(html);\r\n\t\t\r\n\t\tvar lines = splitLines(html),\r\n\t\t\tpadLength = this.getParam('pad-line-numbers'),\r\n\t\t\tfirstLine = parseInt(this.getParam('first-line')),\r\n\t\t\thtml = '',\r\n\t\t\tbrushName = this.getParam('brush')\r\n\t\t\t;\r\n\r\n\t\tfor (var i = 0; i < lines.length; i++)\r\n\t\t{\r\n\t\t\tvar line = lines[i],\r\n\t\t\t\tindent = /^(&nbsp;|\\s)+/.exec(line),\r\n\t\t\t\tspaces = null,\r\n\t\t\t\tlineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;\r\n\t\t\t\t;\r\n\r\n\t\t\tif (indent != null)\r\n\t\t\t{\r\n\t\t\t\tspaces = indent[0].toString();\r\n\t\t\t\tline = line.substr(spaces.length);\r\n\t\t\t\tspaces = spaces.replace(' ', sh.config.space);\r\n\t\t\t}\r\n\r\n\t\t\tline = trim(line);\r\n\t\t\t\r\n\t\t\tif (line.length == 0)\r\n\t\t\t\tline = sh.config.space;\r\n\t\t\t\r\n\t\t\thtml += this.getLineHtml(\r\n\t\t\t\ti,\r\n\t\t\t\tlineNumber, \r\n\t\t\t\t(spaces != null ? '<code class=\"' + brushName + ' spaces\">' + spaces + '</code>' : '') + line\r\n\t\t\t);\r\n\t\t}\r\n\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Returns HTML for the table title or empty string if title is null.\r\n\t */\r\n\tgetTitleHtml: function(title)\r\n\t{\r\n\t\treturn title ? '<caption>' + title + '</caption>' : '';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Finds all matches in the source code.\r\n\t * @param {String} code\t\tSource code to process matches in.\r\n\t * @param {Array} matches\tDiscovered regex matches.\r\n\t * @return {String} Returns formatted HTML with processed mathes.\r\n\t */\r\n\tgetMatchesHtml: function(code, matches)\r\n\t{\r\n\t\tvar pos = 0, \r\n\t\t\tresult = '',\r\n\t\t\tbrushName = this.getParam('brush', '')\r\n\t\t\t;\r\n\t\t\r\n\t\tfunction getBrushNameCss(match)\r\n\t\t{\r\n\t\t\tvar result = match ? (match.brushName || brushName) : brushName;\r\n\t\t\treturn result ? result + ' ' : '';\r\n\t\t};\r\n\t\t\r\n\t\t// Finally, go through the final list of matches and pull the all\r\n\t\t// together adding everything in between that isn't a match.\r\n\t\tfor (var i = 0; i < matches.length; i++) \r\n\t\t{\r\n\t\t\tvar match = matches[i],\r\n\t\t\t\tmatchBrushName\r\n\t\t\t\t;\r\n\t\t\t\r\n\t\t\tif (match === null || match.length === 0) \r\n\t\t\t\tcontinue;\r\n\t\t\t\r\n\t\t\tmatchBrushName = getBrushNameCss(match);\r\n\t\t\t\r\n\t\t\tresult += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')\r\n\t\t\t\t\t+ wrapLinesWithCode(match.value, matchBrushName + match.css)\r\n\t\t\t\t\t;\r\n\r\n\t\t\tpos = match.index + match.length + (match.offset || 0);\r\n\t\t}\r\n\r\n\t\t// don't forget to add whatever's remaining in the string\r\n\t\tresult += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');\r\n\r\n\t\treturn result;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Generates HTML markup for the whole syntax highlighter.\r\n\t * @param {String} code Source code.\r\n\t * @return {String} Returns HTML markup.\r\n\t */\r\n\tgetHtml: function(code)\r\n\t{\r\n\t\tvar html = '',\r\n\t\t\tclasses = [ 'syntaxhighlighter' ],\r\n\t\t\ttabSize,\r\n\t\t\tmatches,\r\n\t\t\tlineNumbers\r\n\t\t\t;\r\n\t\t\r\n\t\t// process light mode\r\n\t\tif (this.getParam('light') == true)\r\n\t\t\tthis.params.toolbar = this.params.gutter = false;\r\n\r\n\t\tclassName = 'syntaxhighlighter';\r\n\r\n\t\tif (this.getParam('collapse') == true)\r\n\t\t\tclasses.push('collapsed');\r\n\t\t\r\n\t\tif ((gutter = this.getParam('gutter')) == false)\r\n\t\t\tclasses.push('nogutter');\r\n\r\n\t\t// add custom user style name\r\n\t\tclasses.push(this.getParam('class-name'));\r\n\r\n\t\t// add brush alias to the class name for custom CSS\r\n\t\tclasses.push(this.getParam('brush'));\r\n\r\n\t\tcode = trimFirstAndLastLines(code)\r\n\t\t\t.replace(/\\r/g, ' ') // IE lets these buggers through\r\n\t\t\t;\r\n\r\n\t\ttabSize = this.getParam('tab-size');\r\n\r\n\t\t// replace tabs with spaces\r\n\t\tcode = this.getParam('smart-tabs') == true\r\n\t\t\t? processSmartTabs(code, tabSize)\r\n\t\t\t: processTabs(code, tabSize)\r\n\t\t\t;\r\n\r\n\t\t// unindent code by the common indentation\r\n\t\tcode = unindent(code);\r\n\r\n\t\tif (gutter)\r\n\t\t\tlineNumbers = this.figureOutLineNumbers(code);\r\n\t\t\r\n\t\t// find matches in the code using brushes regex list\r\n\t\tmatches = this.findMatches(this.regexList, code);\r\n\t\t// processes found matches into the html\r\n\t\thtml = this.getMatchesHtml(code, matches);\r\n\t\t// finally, split all lines so that they wrap well\r\n\t\thtml = this.getCodeLinesHtml(html, lineNumbers);\r\n\r\n\t\t// finally, process the links\r\n\t\tif (this.getParam('auto-links'))\r\n\t\t\thtml = processUrls(html);\r\n\t\t\r\n\t\tif (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))\r\n\t\t\tclasses.push('ie');\r\n\t\t\r\n\t\thtml = \r\n\t\t\t'<div id=\"' + getHighlighterId(this.id) + '\" class=\"' + classes.join(' ') + '\">'\r\n\t\t\t\t+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')\r\n\t\t\t\t+ '<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">'\r\n\t\t\t\t\t+ this.getTitleHtml(this.getParam('title'))\r\n\t\t\t\t\t+ '<tbody>'\r\n\t\t\t\t\t\t+ '<tr>'\r\n\t\t\t\t\t\t\t+ (gutter ? '<td class=\"gutter\">' + this.getLineNumbersHtml(code) + '</td>' : '')\r\n\t\t\t\t\t\t\t+ '<td class=\"code\">'\r\n\t\t\t\t\t\t\t\t+ '<div class=\"container\">'\r\n\t\t\t\t\t\t\t\t\t+ html\r\n\t\t\t\t\t\t\t\t+ '</div>'\r\n\t\t\t\t\t\t\t+ '</td>'\r\n\t\t\t\t\t\t+ '</tr>'\r\n\t\t\t\t\t+ '</tbody>'\r\n\t\t\t\t+ '</table>'\r\n\t\t\t+ '</div>'\r\n\t\t\t;\r\n\t\t\t\r\n\t\treturn html;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Highlights the code and returns complete HTML.\r\n\t * @param {String} code     Code to highlight.\r\n\t * @return {Element}        Returns container DIV element with all markup.\r\n\t */\r\n\tgetDiv: function(code)\r\n\t{\r\n\t\tif (code === null) \r\n\t\t\tcode = '';\r\n\t\t\r\n\t\tthis.code = code;\r\n\r\n\t\tvar div = this.create('div');\r\n\r\n\t\t// create main HTML\r\n\t\tdiv.innerHTML = this.getHtml(code);\r\n\t\t\r\n\t\t// set up click handlers\r\n\t\tif (this.getParam('toolbar'))\r\n\t\t\tattachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);\r\n\t\t\r\n\t\tif (this.getParam('quick-code'))\r\n\t\t\tattachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);\r\n\t\t\r\n\t\treturn div;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Initializes the highlighter/brush.\r\n\t *\r\n\t * Constructor isn't used for initialization so that nothing executes during necessary\r\n\t * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.\r\n\t *\r\n\t * @param {Hash} params Highlighter parameters.\r\n\t */\r\n\tinit: function(params)\r\n\t{\r\n\t\tthis.id = guid();\r\n\t\t\r\n\t\t// register this instance in the highlighters list\r\n\t\tstoreHighlighter(this);\r\n\t\t\r\n\t\t// local params take precedence over defaults\r\n\t\tthis.params = merge(sh.defaults, params || {})\r\n\t\t\r\n\t\t// process light mode\r\n\t\tif (this.getParam('light') == true)\r\n\t\t\tthis.params.toolbar = this.params.gutter = false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Converts space separated list of keywords into a regular expression string.\r\n\t * @param {String} str    Space separated keywords.\r\n\t * @return {String}       Returns regular expression string.\r\n\t */\r\n\tgetKeywords: function(str)\r\n\t{\r\n\t\tstr = str\r\n\t\t\t.replace(/^\\s+|\\s+$/g, '')\r\n\t\t\t.replace(/\\s+/g, '|')\r\n\t\t\t;\r\n\t\t\r\n\t\treturn '\\\\b(?:' + str + ')\\\\b';\r\n\t},\r\n\t\r\n\t/**\r\n\t * Makes a brush compatible with the `html-script` functionality.\r\n\t * @param {Object} regexGroup Object containing `left` and `right` regular expressions.\r\n\t */\r\n\tforHtmlScript: function(regexGroup)\r\n\t{\r\n\t\tthis.htmlScript = {\r\n\t\t\tleft : { regex: regexGroup.left, css: 'script' },\r\n\t\t\tright : { regex: regexGroup.right, css: 'script' },\r\n\t\t\tcode : new XRegExp(\r\n\t\t\t\t\"(?<left>\" + regexGroup.left.source + \")\" +\r\n\t\t\t\t\"(?<code>.*?)\" +\r\n\t\t\t\t\"(?<right>\" + regexGroup.right.source + \")\",\r\n\t\t\t\t\"sgi\"\r\n\t\t\t\t)\r\n\t\t};\r\n\t}\r\n}; // end of Highlighter\r\n\r\nreturn sh;\r\n}(); // end of anonymous function\r\n\r\n// CommonJS\r\ntypeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;"],[1,"eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])}}return p}('K M;I(M)1S 2U(\"2a\\'t 4k M 4K 2g 3l 4G 4H\");(6(){6 r(f,e){I(!M.1R(f))1S 3m(\"3s 15 4R\");K a=f.1w;f=M(f.1m,t(f)+(e||\"\"));I(a)f.1w={1m:a.1m,19:a.19?a.19.1a(0):N};H f}6 t(f){H(f.1J?\"g\":\"\")+(f.4s?\"i\":\"\")+(f.4p?\"m\":\"\")+(f.4v?\"x\":\"\")+(f.3n?\"y\":\"\")}6 B(f,e,a,b){K c=u.L,d,h,g;v=R;5K{O(;c--;){g=u[c];I(a&g.3r&&(!g.2p||g.2p.W(b))){g.2q.12=e;I((h=g.2q.X(f))&&h.P===e){d={3k:g.2b.W(b,h,a),1C:h};1N}}}}5v(i){1S i}5q{v=11}H d}6 p(f,e,a){I(3b.Z.1i)H f.1i(e,a);O(a=a||0;a<f.L;a++)I(f[a]===e)H a;H-1}M=6(f,e){K a=[],b=M.1B,c=0,d,h;I(M.1R(f)){I(e!==1d)1S 3m(\"2a\\'t 5r 5I 5F 5B 5C 15 5E 5p\");H r(f)}I(v)1S 2U(\"2a\\'t W 3l M 59 5m 5g 5x 5i\");e=e||\"\";O(d={2N:11,19:[],2K:6(g){H e.1i(g)>-1},3d:6(g){e+=g}};c<f.L;)I(h=B(f,c,b,d)){a.U(h.3k);c+=h.1C[0].L||1}Y I(h=n.X.W(z[b],f.1a(c))){a.U(h[0]);c+=h[0].L}Y{h=f.3a(c);I(h===\"[\")b=M.2I;Y I(h===\"]\")b=M.1B;a.U(h);c++}a=15(a.1K(\"\"),n.Q.W(e,w,\"\"));a.1w={1m:f,19:d.2N?d.19:N};H a};M.3v=\"1.5.0\";M.2I=1;M.1B=2;K C=/\\\\$(?:(\\\\d\\\\d?|[$&`\\'])|{([$\\\\w]+)})/g,w=/[^5h]+|([\\\\s\\\\S])(?=[\\\\s\\\\S]*\\\\1)/g,A=/^(?:[?*+]|{\\\\d+(?:,\\\\d*)?})\\\\??/,v=11,u=[],n={X:15.Z.X,1A:15.Z.1A,1C:1r.Z.1C,Q:1r.Z.Q,1e:1r.Z.1e},x=n.X.W(/()??/,\"\")[1]===1d,D=6(){K f=/^/g;n.1A.W(f,\"\");H!f.12}(),y=6(){K f=/x/g;n.Q.W(\"x\",f,\"\");H!f.12}(),E=15.Z.3n!==1d,z={};z[M.2I]=/^(?:\\\\\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\\\29-26-f]{2}|u[\\\\29-26-f]{4}|c[A-3o-z]|[\\\\s\\\\S]))/;z[M.1B]=/^(?:\\\\\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\\\d*|x[\\\\29-26-f]{2}|u[\\\\29-26-f]{4}|c[A-3o-z]|[\\\\s\\\\S])|\\\\(\\\\?[:=!]|[?*+]\\\\?|{\\\\d+(?:,\\\\d*)?}\\\\??)/;M.1h=6(f,e,a,b){u.U({2q:r(f,\"g\"+(E?\"y\":\"\")),2b:e,3r:a||M.1B,2p:b||N})};M.2n=6(f,e){K a=f+\"/\"+(e||\"\");H M.2n[a]||(M.2n[a]=M(f,e))};M.3c=6(f){H r(f,\"g\")};M.5l=6(f){H f.Q(/[-[\\\\]{}()*+?.,\\\\\\\\^$|#\\\\s]/g,\"\\\\\\\\$&\")};M.5e=6(f,e,a,b){e=r(e,\"g\"+(b&&E?\"y\":\"\"));e.12=a=a||0;f=e.X(f);H b?f&&f.P===a?f:N:f};M.3q=6(){M.1h=6(){1S 2U(\"2a\\'t 55 1h 54 3q\")}};M.1R=6(f){H 53.Z.1q.W(f)===\"[2m 15]\"};M.3p=6(f,e,a,b){O(K c=r(e,\"g\"),d=-1,h;h=c.X(f);){a.W(b,h,++d,f,c);c.12===h.P&&c.12++}I(e.1J)e.12=0};M.57=6(f,e){H 6 a(b,c){K d=e[c].1I?e[c]:{1I:e[c]},h=r(d.1I,\"g\"),g=[],i;O(i=0;i<b.L;i++)M.3p(b[i],h,6(k){g.U(d.3j?k[d.3j]||\"\":k[0])});H c===e.L-1||!g.L?g:a(g,c+1)}([f],0)};15.Z.1p=6(f,e){H J.X(e[0])};15.Z.W=6(f,e){H J.X(e)};15.Z.X=6(f){K e=n.X.1p(J,14),a;I(e){I(!x&&e.L>1&&p(e,\"\")>-1){a=15(J.1m,n.Q.W(t(J),\"g\",\"\"));n.Q.W(f.1a(e.P),a,6(){O(K c=1;c<14.L-2;c++)I(14[c]===1d)e[c]=1d})}I(J.1w&&J.1w.19)O(K b=1;b<e.L;b++)I(a=J.1w.19[b-1])e[a]=e[b];!D&&J.1J&&!e[0].L&&J.12>e.P&&J.12--}H e};I(!D)15.Z.1A=6(f){(f=n.X.W(J,f))&&J.1J&&!f[0].L&&J.12>f.P&&J.12--;H!!f};1r.Z.1C=6(f){M.1R(f)||(f=15(f));I(f.1J){K e=n.1C.1p(J,14);f.12=0;H e}H f.X(J)};1r.Z.Q=6(f,e){K a=M.1R(f),b,c;I(a&&1j e.58()===\"3f\"&&e.1i(\"${\")===-1&&y)H n.Q.1p(J,14);I(a){I(f.1w)b=f.1w.19}Y f+=\"\";I(1j e===\"6\")c=n.Q.W(J,f,6(){I(b){14[0]=1f 1r(14[0]);O(K d=0;d<b.L;d++)I(b[d])14[0][b[d]]=14[d+1]}I(a&&f.1J)f.12=14[14.L-2]+14[0].L;H e.1p(N,14)});Y{c=J+\"\";c=n.Q.W(c,f,6(){K d=14;H n.Q.W(e,C,6(h,g,i){I(g)5b(g){24\"$\":H\"$\";24\"&\":H d[0];24\"`\":H d[d.L-1].1a(0,d[d.L-2]);24\"\\'\":H d[d.L-1].1a(d[d.L-2]+d[0].L);5a:i=\"\";g=+g;I(!g)H h;O(;g>d.L-3;){i=1r.Z.1a.W(g,-1)+i;g=1Q.3i(g/10)}H(g?d[g]||\"\":\"$\")+i}Y{g=+i;I(g<=d.L-3)H d[g];g=b?p(b,i):-1;H g>-1?d[g+1]:h}})})}I(a&&f.1J)f.12=0;H c};1r.Z.1e=6(f,e){I(!M.1R(f))H n.1e.1p(J,14);K a=J+\"\",b=[],c=0,d,h;I(e===1d||+e<0)e=5D;Y{e=1Q.3i(+e);I(!e)H[]}O(f=M.3c(f);d=f.X(a);){I(f.12>c){b.U(a.1a(c,d.P));d.L>1&&d.P<a.L&&3b.Z.U.1p(b,d.1a(1));h=d[0].L;c=f.12;I(b.L>=e)1N}f.12===d.P&&f.12++}I(c===a.L){I(!n.1A.W(f,\"\")||h)b.U(\"\")}Y b.U(a.1a(c));H b.L>e?b.1a(0,e):b};M.1h(/\\\\(\\\\?#[^)]*\\\\)/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?\"\":\"(?:)\"});M.1h(/\\\\((?!\\\\?)/,6(){J.19.U(N);H\"(\"});M.1h(/\\\\(\\\\?<([$\\\\w]+)>/,6(f){J.19.U(f[1]);J.2N=R;H\"(\"});M.1h(/\\\\\\\\k<([\\\\w$]+)>/,6(f){K e=p(J.19,f[1]);H e>-1?\"\\\\\\\\\"+(e+1)+(3R(f.2S.3a(f.P+f[0].L))?\"\":\"(?:)\"):f[0]});M.1h(/\\\\[\\\\^?]/,6(f){H f[0]===\"[]\"?\"\\\\\\\\b\\\\\\\\B\":\"[\\\\\\\\s\\\\\\\\S]\"});M.1h(/^\\\\(\\\\?([5A]+)\\\\)/,6(f){J.3d(f[1]);H\"\"});M.1h(/(?:\\\\s+|#.*)+/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?\"\":\"(?:)\"},M.1B,6(){H J.2K(\"x\")});M.1h(/\\\\./,6(){H\"[\\\\\\\\s\\\\\\\\S]\"},M.1B,6(){H J.2K(\"s\")})})();1j 2e!=\"1d\"&&(2e.M=M);K 1v=6(){6 r(a,b){a.1l.1i(b)!=-1||(a.1l+=\" \"+b)}6 t(a){H a.1i(\"3e\")==0?a:\"3e\"+a}6 B(a){H e.1Y.2A[t(a)]}6 p(a,b,c){I(a==N)H N;K d=c!=R?a.3G:[a.2G],h={\"#\":\"1c\",\".\":\"1l\"}[b.1o(0,1)]||\"3h\",g,i;g=h!=\"3h\"?b.1o(1):b.5u();I((a[h]||\"\").1i(g)!=-1)H a;O(a=0;d&&a<d.L&&i==N;a++)i=p(d[a],b,c);H i}6 C(a,b){K c={},d;O(d 2g a)c[d]=a[d];O(d 2g b)c[d]=b[d];H c}6 w(a,b,c,d){6 h(g){g=g||1P.5y;I(!g.1F){g.1F=g.52;g.3N=6(){J.5w=11}}c.W(d||1P,g)}a.3g?a.3g(\"4U\"+b,h):a.4y(b,h,11)}6 A(a,b){K c=e.1Y.2j,d=N;I(c==N){c={};O(K h 2g e.1U){K g=e.1U[h];d=g.4x;I(d!=N){g.1V=h.4w();O(g=0;g<d.L;g++)c[d[g]]=h}}e.1Y.2j=c}d=e.1U[c[a]];d==N&&b!=11&&1P.1X(e.13.1x.1X+(e.13.1x.3E+a));H d}6 v(a,b){O(K c=a.1e(\"\\\\n\"),d=0;d<c.L;d++)c[d]=b(c[d],d);H c.1K(\"\\\\n\")}6 u(a,b){I(a==N||a.L==0||a==\"\\\\n\")H a;a=a.Q(/</g,\"&1y;\");a=a.Q(/ {2,}/g,6(c){O(K d=\"\",h=0;h<c.L-1;h++)d+=e.13.1W;H d+\" \"});I(b!=N)a=v(a,6(c){I(c.L==0)H\"\";K d=\"\";c=c.Q(/^(&2s;| )+/,6(h){d=h;H\"\"});I(c.L==0)H d;H d+\\'<17 1g=\"\\'+b+\\'\">\\'+c+\"</17>\"});H a}6 n(a,b){a.1e(\"\\\\n\");O(K c=\"\",d=0;d<50;d++)c+=\"                    \";H a=v(a,6(h){I(h.1i(\"\\\\t\")==-1)H h;O(K g=0;(g=h.1i(\"\\\\t\"))!=-1;)h=h.1o(0,g)+c.1o(0,b-g%b)+h.1o(g+1,h.L);H h})}6 x(a){H a.Q(/^\\\\s+|\\\\s+$/g,\"\")}6 D(a,b){I(a.P<b.P)H-1;Y I(a.P>b.P)H 1;Y I(a.L<b.L)H-1;Y I(a.L>b.L)H 1;H 0}6 y(a,b){6 c(k){H k[0]}O(K d=N,h=[],g=b.2D?b.2D:c;(d=b.1I.X(a))!=N;){K i=g(d,b);I(1j i==\"3f\")i=[1f e.2L(i,d.P,b.23)];h=h.1O(i)}H h}6 E(a){K b=/(.*)((&1G;|&1y;).*)/;H a.Q(e.3A.3M,6(c){K d=\"\",h=N;I(h=b.X(c)){c=h[1];d=h[2]}H\\'<a 2h=\"\\'+c+\\'\">\\'+c+\"</a>\"+d})}6 z(){O(K a=1E.36(\"1k\"),b=[],c=0;c<a.L;c++)a[c].3s==\"20\"&&b.U(a[c]);H b}6 f(a){a=a.1F;K b=p(a,\".20\",R);a=p(a,\".3O\",R);K c=1E.4i(\"3t\");I(!(!a||!b||p(a,\"3t\"))){B(b.1c);r(b,\"1m\");O(K d=a.3G,h=[],g=0;g<d.L;g++)h.U(d[g].4z||d[g].4A);h=h.1K(\"\\\\r\");c.39(1E.4D(h));a.39(c);c.2C();c.4C();w(c,\"4u\",6(){c.2G.4E(c);b.1l=b.1l.Q(\"1m\",\"\")})}}I(1j 3F!=\"1d\"&&1j M==\"1d\")M=3F(\"M\").M;K e={2v:{\"1g-27\":\"\",\"2i-1s\":1,\"2z-1s-2t\":11,1M:N,1t:N,\"42-45\":R,\"43-22\":4,1u:R,16:R,\"3V-17\":R,2l:11,\"41-40\":R,2k:11,\"1z-1k\":11},13:{1W:\"&2s;\",2M:R,46:11,44:11,34:\"4n\",1x:{21:\"4o 1m\",2P:\"?\",1X:\"1v\\\\n\\\\n\",3E:\"4r\\'t 4t 1D O: \",4g:\"4m 4B\\'t 51 O 1z-1k 4F: \",37:\\'<!4T 1z 4S \"-//4V//3H 4W 1.0 4Z//4Y\" \"1Z://2y.3L.3K/4X/3I/3H/3I-4P.4J\"><1z 4I=\"1Z://2y.3L.3K/4L/5L\"><3J><4N 1Z-4M=\"5G-5M\" 6K=\"2O/1z; 6J=6I-8\" /><1t>6L 1v</1t></3J><3B 1L=\"25-6M:6Q,6P,6O,6N-6F;6y-2f:#6x;2f:#6w;25-22:6v;2O-3D:3C;\"><T 1L=\"2O-3D:3C;3w-32:1.6z;\"><T 1L=\"25-22:6A-6E;\">1v</T><T 1L=\"25-22:.6C;3w-6B:6R;\"><T>3v 3.0.76 (72 73 3x)</T><T><a 2h=\"1Z://3u.2w/1v\" 1F=\"38\" 1L=\"2f:#3y\">1Z://3u.2w/1v</a></T><T>70 17 6U 71.</T><T>6T 6X-3x 6Y 6D.</T></T><T>6t 61 60 J 1k, 5Z <a 2h=\"6u://2y.62.2w/63-66/65?64=5X-5W&5P=5O\" 1L=\"2f:#3y\">5R</a> 5V <2R/>5U 5T 5S!</T></T></3B></1z>\\'}},1Y:{2j:N,2A:{}},1U:{},3A:{6n:/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\//2c,6m:/\\\\/\\\\/.*$/2c,6l:/#.*$/2c,6k:/\"([^\\\\\\\\\"\\\\n]|\\\\\\\\.)*\"/g,6o:/\\'([^\\\\\\\\\\'\\\\n]|\\\\\\\\.)*\\'/g,6p:1f M(\\'\"([^\\\\\\\\\\\\\\\\\"]|\\\\\\\\\\\\\\\\.)*\"\\',\"3z\"),6s:1f M(\"\\'([^\\\\\\\\\\\\\\\\\\']|\\\\\\\\\\\\\\\\.)*\\'\",\"3z\"),6q:/(&1y;|<)!--[\\\\s\\\\S]*?--(&1G;|>)/2c,3M:/\\\\w+:\\\\/\\\\/[\\\\w-.\\\\/?%&=:@;]*/g,6a:{18:/(&1y;|<)\\\\?=?/g,1b:/\\\\?(&1G;|>)/g},69:{18:/(&1y;|<)%=?/g,1b:/%(&1G;|>)/g},6d:{18:/(&1y;|<)\\\\s*1k.*?(&1G;|>)/2T,1b:/(&1y;|<)\\\\/\\\\s*1k\\\\s*(&1G;|>)/2T}},16:{1H:6(a){6 b(i,k){H e.16.2o(i,k,e.13.1x[k])}O(K c=\\'<T 1g=\"16\">\\',d=e.16.2x,h=d.2X,g=0;g<h.L;g++)c+=(d[h[g]].1H||b)(a,h[g]);c+=\"</T>\";H c},2o:6(a,b,c){H\\'<2W><a 2h=\"#\" 1g=\"6e 6h\\'+b+\" \"+b+\\'\">\\'+c+\"</a></2W>\"},2b:6(a){K b=a.1F,c=b.1l||\"\";b=B(p(b,\".20\",R).1c);K d=6(h){H(h=15(h+\"6f(\\\\\\\\w+)\").X(c))?h[1]:N}(\"6g\");b&&d&&e.16.2x[d].2B(b);a.3N()},2x:{2X:[\"21\",\"2P\"],21:{1H:6(a){I(a.V(\"2l\")!=R)H\"\";K b=a.V(\"1t\");H e.16.2o(a,\"21\",b?b:e.13.1x.21)},2B:6(a){a=1E.6j(t(a.1c));a.1l=a.1l.Q(\"47\",\"\")}},2P:{2B:6(){K a=\"68=0\";a+=\", 18=\"+(31.30-33)/2+\", 32=\"+(31.2Z-2Y)/2+\", 30=33, 2Z=2Y\";a=a.Q(/^,/,\"\");a=1P.6Z(\"\",\"38\",a);a.2C();K b=a.1E;b.6W(e.13.1x.37);b.6V();a.2C()}}}},35:6(a,b){K c;I(b)c=[b];Y{c=1E.36(e.13.34);O(K d=[],h=0;h<c.L;h++)d.U(c[h]);c=d}c=c;d=[];I(e.13.2M)c=c.1O(z());I(c.L===0)H d;O(h=0;h<c.L;h++){O(K g=c[h],i=a,k=c[h].1l,j=3W 0,l={},m=1f M(\"^\\\\\\\\[(?<2V>(.*?))\\\\\\\\]$\"),s=1f M(\"(?<27>[\\\\\\\\w-]+)\\\\\\\\s*:\\\\\\\\s*(?<1T>[\\\\\\\\w-%#]+|\\\\\\\\[.*?\\\\\\\\]|\\\\\".*?\\\\\"|\\'.*?\\')\\\\\\\\s*;?\",\"g\");(j=s.X(k))!=N;){K o=j.1T.Q(/^[\\'\"]|[\\'\"]$/g,\"\");I(o!=N&&m.1A(o)){o=m.X(o);o=o.2V.L>0?o.2V.1e(/\\\\s*,\\\\s*/):[]}l[j.27]=o}g={1F:g,1n:C(i,l)};g.1n.1D!=N&&d.U(g)}H d},1M:6(a,b){K c=J.35(a,b),d=N,h=e.13;I(c.L!==0)O(K g=0;g<c.L;g++){b=c[g];K i=b.1F,k=b.1n,j=k.1D,l;I(j!=N){I(k[\"1z-1k\"]==\"R\"||e.2v[\"1z-1k\"]==R){d=1f e.4l(j);j=\"4O\"}Y I(d=A(j))d=1f d;Y 6H;l=i.3X;I(h.2M){l=l;K m=x(l),s=11;I(m.1i(\"<![6G[\")==0){m=m.4h(9);s=R}K o=m.L;I(m.1i(\"]]\\\\>\")==o-3){m=m.4h(0,o-3);s=R}l=s?m:l}I((i.1t||\"\")!=\"\")k.1t=i.1t;k.1D=j;d.2Q(k);b=d.2F(l);I((i.1c||\"\")!=\"\")b.1c=i.1c;i.2G.74(b,i)}}},2E:6(a){w(1P,\"4k\",6(){e.1M(a)})}};e.2E=e.2E;e.1M=e.1M;e.2L=6(a,b,c){J.1T=a;J.P=b;J.L=a.L;J.23=c;J.1V=N};e.2L.Z.1q=6(){H J.1T};e.4l=6(a){6 b(j,l){O(K m=0;m<j.L;m++)j[m].P+=l}K c=A(a),d,h=1f e.1U.5Y,g=J,i=\"2F 1H 2Q\".1e(\" \");I(c!=N){d=1f c;O(K k=0;k<i.L;k++)(6(){K j=i[k];g[j]=6(){H h[j].1p(h,14)}})();d.28==N?1P.1X(e.13.1x.1X+(e.13.1x.4g+a)):h.2J.U({1I:d.28.17,2D:6(j){O(K l=j.17,m=[],s=d.2J,o=j.P+j.18.L,F=d.28,q,G=0;G<s.L;G++){q=y(l,s[G]);b(q,o);m=m.1O(q)}I(F.18!=N&&j.18!=N){q=y(j.18,F.18);b(q,j.P);m=m.1O(q)}I(F.1b!=N&&j.1b!=N){q=y(j.1b,F.1b);b(q,j.P+j[0].5Q(j.1b));m=m.1O(q)}O(j=0;j<m.L;j++)m[j].1V=c.1V;H m}})}};e.4j=6(){};e.4j.Z={V:6(a,b){K c=J.1n[a];c=c==N?b:c;K d={\"R\":R,\"11\":11}[c];H d==N?c:d},3Y:6(a){H 1E.4i(a)},4c:6(a,b){K c=[];I(a!=N)O(K d=0;d<a.L;d++)I(1j a[d]==\"2m\")c=c.1O(y(b,a[d]));H J.4e(c.6b(D))},4e:6(a){O(K b=0;b<a.L;b++)I(a[b]!==N)O(K c=a[b],d=c.P+c.L,h=b+1;h<a.L&&a[b]!==N;h++){K g=a[h];I(g!==N)I(g.P>d)1N;Y I(g.P==c.P&&g.L>c.L)a[b]=N;Y I(g.P>=c.P&&g.P<d)a[h]=N}H a},4d:6(a){K b=[],c=2u(J.V(\"2i-1s\"));v(a,6(d,h){b.U(h+c)});H b},3U:6(a){K b=J.V(\"1M\",[]);I(1j b!=\"2m\"&&b.U==N)b=[b];a:{a=a.1q();K c=3W 0;O(c=c=1Q.6c(c||0,0);c<b.L;c++)I(b[c]==a){b=c;1N a}b=-1}H b!=-1},2r:6(a,b,c){a=[\"1s\",\"6i\"+b,\"P\"+a,\"6r\"+(b%2==0?1:2).1q()];J.3U(b)&&a.U(\"67\");b==0&&a.U(\"1N\");H\\'<T 1g=\"\\'+a.1K(\" \")+\\'\">\\'+c+\"</T>\"},3Q:6(a,b){K c=\"\",d=a.1e(\"\\\\n\").L,h=2u(J.V(\"2i-1s\")),g=J.V(\"2z-1s-2t\");I(g==R)g=(h+d-1).1q().L;Y I(3R(g)==R)g=0;O(K i=0;i<d;i++){K k=b?b[i]:h+i,j;I(k==0)j=e.13.1W;Y{j=g;O(K l=k.1q();l.L<j;)l=\"0\"+l;j=l}a=j;c+=J.2r(i,k,a)}H c},49:6(a,b){a=x(a);K c=a.1e(\"\\\\n\");J.V(\"2z-1s-2t\");K d=2u(J.V(\"2i-1s\"));a=\"\";O(K h=J.V(\"1D\"),g=0;g<c.L;g++){K i=c[g],k=/^(&2s;|\\\\s)+/.X(i),j=N,l=b?b[g]:d+g;I(k!=N){j=k[0].1q();i=i.1o(j.L);j=j.Q(\" \",e.13.1W)}i=x(i);I(i.L==0)i=e.13.1W;a+=J.2r(g,l,(j!=N?\\'<17 1g=\"\\'+h+\\' 5N\">\\'+j+\"</17>\":\"\")+i)}H a},4f:6(a){H a?\"<4a>\"+a+\"</4a>\":\"\"},4b:6(a,b){6 c(l){H(l=l?l.1V||g:g)?l+\" \":\"\"}O(K d=0,h=\"\",g=J.V(\"1D\",\"\"),i=0;i<b.L;i++){K k=b[i],j;I(!(k===N||k.L===0)){j=c(k);h+=u(a.1o(d,k.P-d),j+\"48\")+u(k.1T,j+k.23);d=k.P+k.L+(k.75||0)}}h+=u(a.1o(d),c()+\"48\");H h},1H:6(a){K b=\"\",c=[\"20\"],d;I(J.V(\"2k\")==R)J.1n.16=J.1n.1u=11;1l=\"20\";J.V(\"2l\")==R&&c.U(\"47\");I((1u=J.V(\"1u\"))==11)c.U(\"6S\");c.U(J.V(\"1g-27\"));c.U(J.V(\"1D\"));a=a.Q(/^[ ]*[\\\\n]+|[\\\\n]*[ ]*$/g,\"\").Q(/\\\\r/g,\" \");b=J.V(\"43-22\");I(J.V(\"42-45\")==R)a=n(a,b);Y{O(K h=\"\",g=0;g<b;g++)h+=\" \";a=a.Q(/\\\\t/g,h)}a=a;a:{b=a=a;h=/<2R\\\\s*\\\\/?>|&1y;2R\\\\s*\\\\/?&1G;/2T;I(e.13.46==R)b=b.Q(h,\"\\\\n\");I(e.13.44==R)b=b.Q(h,\"\");b=b.1e(\"\\\\n\");h=/^\\\\s*/;g=4Q;O(K i=0;i<b.L&&g>0;i++){K k=b[i];I(x(k).L!=0){k=h.X(k);I(k==N){a=a;1N a}g=1Q.4q(k[0].L,g)}}I(g>0)O(i=0;i<b.L;i++)b[i]=b[i].1o(g);a=b.1K(\"\\\\n\")}I(1u)d=J.4d(a);b=J.4c(J.2J,a);b=J.4b(a,b);b=J.49(b,d);I(J.V(\"41-40\"))b=E(b);1j 2H!=\"1d\"&&2H.3S&&2H.3S.1C(/5s/)&&c.U(\"5t\");H b=\\'<T 1c=\"\\'+t(J.1c)+\\'\" 1g=\"\\'+c.1K(\" \")+\\'\">\\'+(J.V(\"16\")?e.16.1H(J):\"\")+\\'<3Z 5z=\"0\" 5H=\"0\" 5J=\"0\">\\'+J.4f(J.V(\"1t\"))+\"<3T><3P>\"+(1u?\\'<2d 1g=\"1u\">\\'+J.3Q(a)+\"</2d>\":\"\")+\\'<2d 1g=\"17\"><T 1g=\"3O\">\\'+b+\"</T></2d></3P></3T></3Z></T>\"},2F:6(a){I(a===N)a=\"\";J.17=a;K b=J.3Y(\"T\");b.3X=J.1H(a);J.V(\"16\")&&w(p(b,\".16\"),\"5c\",e.16.2b);J.V(\"3V-17\")&&w(p(b,\".17\"),\"56\",f);H b},2Q:6(a){J.1c=\"\"+1Q.5d(1Q.5n()*5k).1q();e.1Y.2A[t(J.1c)]=J;J.1n=C(e.2v,a||{});I(J.V(\"2k\")==R)J.1n.16=J.1n.1u=11},5j:6(a){a=a.Q(/^\\\\s+|\\\\s+$/g,\"\").Q(/\\\\s+/g,\"|\");H\"\\\\\\\\b(?:\"+a+\")\\\\\\\\b\"},5f:6(a){J.28={18:{1I:a.18,23:\"1k\"},1b:{1I:a.1b,23:\"1k\"},17:1f M(\"(?<18>\"+a.18.1m+\")(?<17>.*?)(?<1b>\"+a.1b.1m+\")\",\"5o\")}}};H e}();1j 2e!=\"1d\"&&(2e.1v=1v);',62,441,'||||||function|||||||||||||||||||||||||||||||||||||return|if|this|var|length|XRegExp|null|for|index|replace|true||div|push|getParam|call|exec|else|prototype||false|lastIndex|config|arguments|RegExp|toolbar|code|left|captureNames|slice|right|id|undefined|split|new|class|addToken|indexOf|typeof|script|className|source|params|substr|apply|toString|String|line|title|gutter|SyntaxHighlighter|_xregexp|strings|lt|html|test|OUTSIDE_CLASS|match|brush|document|target|gt|getHtml|regex|global|join|style|highlight|break|concat|window|Math|isRegExp|throw|value|brushes|brushName|space|alert|vars|http|syntaxhighlighter|expandSource|size|css|case|font|Fa|name|htmlScript|dA|can|handler|gm|td|exports|color|in|href|first|discoveredBrushes|light|collapse|object|cache|getButtonHtml|trigger|pattern|getLineHtml|nbsp|numbers|parseInt|defaults|com|items|www|pad|highlighters|execute|focus|func|all|getDiv|parentNode|navigator|INSIDE_CLASS|regexList|hasFlag|Match|useScriptTags|hasNamedCapture|text|help|init|br|input|gi|Error|values|span|list|250|height|width|screen|top|500|tagName|findElements|getElementsByTagName|aboutDialog|_blank|appendChild|charAt|Array|copyAsGlobal|setFlag|highlighter_|string|attachEvent|nodeName|floor|backref|output|the|TypeError|sticky|Za|iterate|freezeTokens|scope|type|textarea|alexgorbatchev|version|margin|2010|005896|gs|regexLib|body|center|align|noBrush|require|childNodes|DTD|xhtml1|head|org|w3|url|preventDefault|container|tr|getLineNumbersHtml|isNaN|userAgent|tbody|isLineHighlighted|quick|void|innerHTML|create|table|links|auto|smart|tab|stripBrs|tabs|bloggerMode|collapsed|plain|getCodeLinesHtml|caption|getMatchesHtml|findMatches|figureOutLineNumbers|removeNestedMatches|getTitleHtml|brushNotHtmlScript|substring|createElement|Highlighter|load|HtmlScript|Brush|pre|expand|multiline|min|Can|ignoreCase|find|blur|extended|toLowerCase|aliases|addEventListener|innerText|textContent|wasn|select|createTextNode|removeChild|option|same|frame|xmlns|dtd|twice|1999|equiv|meta|htmlscript|transitional|1E3|expected|PUBLIC|DOCTYPE|on|W3C|XHTML|TR|EN|Transitional||configured|srcElement|Object|after|run|dblclick|matchChain|valueOf|constructor|default|switch|click|round|execAt|forHtmlScript|token|gimy|functions|getKeywords|1E6|escape|within|random|sgi|another|finally|supply|MSIE|ie|toUpperCase|catch|returnValue|definition|event|border|imsx|constructing|one|Infinity|from|when|Content|cellpadding|flags|cellspacing|try|xhtml|Type|spaces|2930402|hosted_button_id|lastIndexOf|donate|active|development|keep|to|xclick|_s|Xml|please|like|you|paypal|cgi|cmd|webscr|bin|highlighted|scrollbars|aspScriptTags|phpScriptTags|sort|max|scriptScriptTags|toolbar_item|_|command|command_|number|getElementById|doubleQuotedString|singleLinePerlComments|singleLineCComments|multiLineCComments|singleQuotedString|multiLineDoubleQuotedString|xmlComments|alt|multiLineSingleQuotedString|If|https|1em|000|fff|background|5em|xx|bottom|75em|Gorbatchev|large|serif|CDATA|continue|utf|charset|content|About|family|sans|Helvetica|Arial|Geneva|3em|nogutter|Copyright|syntax|close|write|2004|Alex|open|JavaScript|highlighter|July|02|replaceChild|offset|83'.split('|'),0,{}))"],[0,"\r\n"]],"start1":390,"start2":390,"length1":44836,"length2":15802}]],"length":16192,"saved":false}
